#include "MAPL_Generic.h"
#if defined(I_AM_PFUNIT)
#  undef I_AM_PFUNIT
#endif
#define I_AM_PFUNIT

module Test_ExtDataUpdatePointer
   use MAPL_ExtDataPointerUpdate
   use funit
   use esmf
   use MAPL_ExceptionHandling
   implicit none


   integer, parameter :: SUCCESS = 0
   integer, parameter :: TIME_STEP_IN_SECONDS = 1
   integer, parameter :: REFERENCE_TIME_FIELDS(*) = [2024, 12, 31, 20, 0, 0]
   integer, parameter :: NF = size(REFERENCE_TIME_FIELDS)
   integer, parameter :: START_TIME_FIELDS(*) = [2024, 01, 01, 0, 0, 0] 
   integer, parameter :: DEFAULT_TIME_FIELDS(*) = [REFERENCE_TIME_FIELDS(1:3), 0, 0, 0]
   integer, parameter :: UPDATE_TIME_FIELDS(*) = [0, 1, 1, REFERENCE_TIME_FIELDS(4:)]
   integer :: actual(NF), expected(NF)
   character(len=*), parameter :: UPDATE_TIMESTRING = 'T20:00:00'
   character(len=*), parameter :: UPDATE_FREQ_STRING = '-'
   type(ESMF_Time) :: start_time
   type(ESMF_TimeInterval) :: timestep
   type(ESMF_Clock) :: clock
   type(ESMF_Time) :: previous_time
   type(ESMF_TimeInterval) :: time_interval
   type(ESMF_Time) :: update_time
   type(ESMF_Time) :: reference_time

contains

   @Before
   subroutine set_up()
      integer :: status, rc
      logical :: uninitialized

      status = SUCCESS
      uninitialized = .not. ESMF_IsInitialized(_RC)
!      if(uninitialized) call set_up_initial(REFERENCE_TIME_FIELDS, DEFAULT_TIME_FIELDS, UPDATE_TIME_FIELDS, _RC)
      if(uninitialized) then
         call ESMF_Initialize(defaultCalKind=ESMF_CALKIND_GREGORIAN, logKindFlag=ESMF_LOGKIND_NONE, defaultLogKindFlag=ESMF_LOGKIND_NONE, _RC)
      end if
      call ESMF_TimeIntervalSet(time_interval, _RC)
      call ESMF_TimeIntervalSet(timestep, s=TIME_STEP_IN_SECONDS, _RC)
      call make_esmf_time(START_TIME_FIELDS, start_time, _RC)
      call make_esmf_time(DEFAULT_TIME_FIELDS, previous_time, _RC)
      call make_esmf_time(UPDATE_TIME_FIELDS, update_time, _RC)
      call make_esmf_time(REFERENCE_TIME_FIELDS, reference_time, _RC)
      clock = ESMF_ClockCreate(timestep=timestep, startTime=start_time, _RC)

   end subroutine set_up

   subroutine set_up_initial(reference, default, update, rc)
      integer, intent(in) :: reference(NF)
      integer, intent(inout) :: default(NF)
      integer, intent(inout) :: update(NF)
      integer, optional, intent(out) :: rc
      integer :: status
      
      status = SUCCESS
      call ESMF_Initialize(defaultCalKind=ESMF_CALKIND_GREGORIAN, logKindFlag=ESMF_LOGKIND_NONE, defaultLogKindFlag=ESMF_LOGKIND_NONE, _RC)
      default = [reference(1:3), 0, 0, 0]
      update = [0, 1, 1, reference(4:)]
      _RETURN(_SUCCESS)
   end subroutine set_up_initial

   @After
   subroutine tear_down()
      integer :: status, rc

      call ESMF_TimeSet(start_time, _RC)
      call ESMF_TimeIntervalSet(timestep, _RC)
      call ESMF_ClockDestroy(clock, _RC)
      call ESMF_TimeSet(previous_time, _RC)
      call ESMF_TimeIntervalSet(time_interval, _RC)
      call ESMF_TimeSet(update_time, _RC)
      call ESMF_TimeSet(reference_time, _RC)

   end subroutine tear_down

   subroutine make_esmf_time(f, datetime, rc)
      integer, intent(in) :: f(NF)
      type(ESMF_Time), intent(inout) :: datetime
      integer, optional, intent(out) :: rc
      integer :: status

      status = 0
      call ESMF_TimeSet(datetime, yy=f(1), mm=f(2), dd=f(3), h=f(4), m=f(5), s=f(6), _RC)
      _RETURN(_SUCCESS)
         
   end subroutine make_esmf_time

   subroutine get_int_time(datetime, n, rc)
      type(ESMF_Time), intent(in) :: datetime
      integer, intent(inout) :: n(NF)
      integer, optional, intent(out) :: rc
      integer :: status

      status = 0
      n = -1
      call ESMF_TimeGet(datetime, yy=n(1), mm=n(2), dd=n(3), h=n(4), m=n(5), s=n(6), _RC)

      _RETURN(_SUCCESS)

   end subroutine get_int_time

   subroutine get_int_time_interval(interval, n, rc)
      type(ESMF_TimeInterval), intent(in) :: interval
      integer, intent(inout) :: n(NF)
      integer, optional, intent(out) :: rc
      integer :: status

      status = 0
      n = 0
      !call ESMF_TimeIntervalGet(interval, yy=n(1), mm=n(2), dd=n(3), h=n(4), m=n(5), s=n(6), _RC)

      _RETURN(_SUCCESS)

   end subroutine get_int_time_interval

   @Test
   subroutine test_get_adjusted_time
      type(ExtDataPointerUpdate) :: ex
      integer :: status, rc
      character(len=32) :: offset_string
      type(ESMF_TimeInterval) :: offset
      integer :: ios
      integer, parameter :: OFFSET_IN_SECONDS = 300

      write(offset_string, fmt='("PT", I03, "S")', iostat=ios) OFFSET_IN_SECONDS
      _VERIFY(ios)
      call ESMF_TimeIntervalSet(offset, s=OFFSET_IN_SECONDS, _RC)
      call get_int_time(previous_time+offset, expected, _RC)
      call ex%create_from_parameters(UPDATE_TIMESTRING, UPDATE_FREQ_STRING, offset_string, previous_time, clock, _RC)
      call get_int_time(ex%get_adjusted_time(previous_time), actual, _RC)
      @assertEqual(expected, actual, 'Adjusted time does match expected time.')

   end subroutine test_get_adjusted_time

   
   @Test
   subroutine test_create_from_parameters_string_positive()
      type(ExtDataPointerUpdate) :: ex
      integer :: status, rc
      character(len=32) :: offset_string
      integer, parameter :: OFFSET_IN_SECONDS = 300
      type(ESMF_TimeInterval) :: offset
      integer :: ios
      integer :: expected, actual
!      logical, parameter :: FIRST_TIME = .TRUE.
!      logical :: do_update
      type(ESMF_TimeInterval) :: interval
!      type(ESMF_Time) :: use_time, current_time

      write(offset_string, fmt='("PT", I03, "S")', iostat=ios) OFFSET_IN_SECONDS
      _VERIFY(ios)
      call ESMF_TimeIntervalSet(offset, s=OFFSET_IN_SECONDS, _RC)
      !call get_int_time_interval(offset, expected, _RC)
      expected = OFFSET_IN_SECONDS
      call ex%create_from_parameters(UPDATE_TIMESTRING, UPDATE_FREQ_STRING, offset_string, previous_time, clock, _RC)
      !call ex%check_update(do_update, use_time, current_time, FIRST_TIME, _RC)
      interval = ex%get_offset()
      call ESMF_TimeIntervalGet(interval, s=actual, _RC)
!      call get_int_time_interval(interval, actual, _RC)
      @assertEqual(expected, actual, 'Updated time interval does match expected time interval.')

   end subroutine test_create_from_parameters_string_positive

   !@Test
   subroutine test_create_from_parameters_string_negative()
      type(ExtDataPointerUpdate) :: ex
      integer :: status, rc
      character(len=32) :: offset_string
      integer, parameter :: OFFSET_IN_SECONDS = 300
      type(ESMF_TimeInterval) :: offset
      integer :: ios
      logical, parameter :: FIRST_TIME = .TRUE.
      logical :: do_update
      type(ESMF_Time) :: use_time, current_time

      write(offset_string, fmt='("PT", I03, "S")', iostat=ios) OFFSET_IN_SECONDS
      offset_string = '-' // offset_string
      _VERIFY(ios)
      call ESMF_TimeIntervalSet(offset, s=-OFFSET_IN_SECONDS, _RC)
!      call get_int_time(reference_time+offset, expected, _RC)
      call ex%create_from_parameters(UPDATE_TIMESTRING, UPDATE_FREQ_STRING, offset_string, previous_time, clock, _RC)
      call ex%check_update(do_update, use_time, current_time, FIRST_TIME, _RC)
!      call get_int_time(use_time, actual, _RC)
      @assertEqual(expected, actual, 'Updated time does match expected time.')

   end subroutine test_create_from_parameters_string_negative

   !@Test
   subroutine test_create_from_parameters_heartbeat_positive()
      type(ExtDataPointerUpdate) :: ex
      integer :: status, rc
      character(len=*), parameter :: OFFSET_STRING = HEARTBEAT_STRING
      type(ESMF_TimeInterval) :: offset
      logical, parameter :: FIRST_TIME = .TRUE.
      logical :: do_update
      type(ESMF_Time) :: use_time, current_time

      offset = timestep
!      call get_int_time(reference_time + offset, expected,_RC)
      call ex%create_from_parameters(UPDATE_TIMESTRING, UPDATE_FREQ_STRING, OFFSET_STRING, previous_time, clock, _RC)
      call ex%check_update(do_update, use_time, current_time, FIRST_TIME, _RC)
!      call get_int_time(use_time, actual, _RC)
      @assertEqual(expected, actual, 'Updated time does match expected time.')

   end subroutine test_create_from_parameters_heartbeat_positive

   !@Test
   subroutine test_create_from_parameters_heartbeat_negative()
      type(ExtDataPointerUpdate) :: ex
      integer :: status, rc
      character(len=*), parameter :: OFFSET_STRING = '-' // HEARTBEAT_STRING
      type(ESMF_TimeInterval) :: offset
      logical, parameter :: FIRST_TIME = .TRUE.
      logical :: do_update
      type(ESMF_Time) :: use_time, current_time

      offset = -timestep
!      call get_int_time(reference_time + offset, expected,_RC)
      call ex%create_from_parameters(UPDATE_TIMESTRING, UPDATE_FREQ_STRING, OFFSET_STRING, previous_time, clock, _RC)
      call ex%check_update(do_update, use_time, current_time, FIRST_TIME, _RC)
!      call get_int_time(use_time, actual, _RC)
      @assertEqual(expected, actual, 'Updated time does match expected time.')

   end subroutine test_create_from_parameters_heartbeat_negative

end module Test_ExtDataUpdatePointer
