#include "MAPL_Generic.h"
#if defined(I_AM_PFUNIT)
#  undef I_AM_PFUNIT
#endif
#define I_AM_PFUNIT

module Test_ExtDataUpdatePointer
   use MAPL_ExtDataPointerUpdate
   use funit
   use esmf
   use MAPL_ExceptionHandling
   implicit none


   integer, parameter :: TIME_STEP_IN_SECONDS = 1
   integer, parameter :: REFERENCE_TIME_FIELDS(*) = [2024, 12, 31, 20]
   integer, parameter :: START_TIME_FIELDS(*) = [2024, 01, 01] 
   integer, parameter :: DEFAULT_TIME_FIELDS(*) = REFERENCE_TIME_FIELDS(1:3)
   integer, parameter :: UPDATE_TIME_FIELDS(*) = REFERENCE_TIME_FIELDS(4:)
   character(len=*), parameter :: UPDATE_TIMESTRING = 'T20:00:00'
   character(len=*), parameter :: UPDATE_FREQ_STRING = '-'
   type(ESMF_Time) :: start_time
   type(ESMF_TimeInterval) :: timestep
   type(ESMF_Clock) :: clock
   type(ESMF_Time) :: time
   type(ESMF_TimeInterval) :: time_interval
   type(ESMF_Time) :: update_time
   type(ESMF_Time) :: reference_time
   integer, parameter :: SUCCESS = 0

contains

   @Before
   subroutine set_up()
      integer :: status, rc

      status = SUCCESS
      call ESMF_Initialize(defaultCalKind=ESMF_CALKIND_GREGORIAN, _RC)
      call ESMF_TimeIntervalSet(time_interval, _RC)
      call ESMF_TimeIntervalSet(timestep, s=TIME_STEP_IN_SECONDS, _RC)
      call make_esmf_time(START_TIME_FIELDS, start_time, _RC)
      call make_esmf_time(DEFAULT_TIME_FIELDS, time, _RC)
      call make_esmf_time(UPDATE_TIME_FIELDS, update_time, time_only=.TRUE., _RC)
      call make_esmf_time(REFERENCE_TIME_FIELDS, reference_time, _RC)
      clock = ESMF_ClockCreate(timestep=timestep, startTime=start_time, _RC)
      
   end subroutine set_up

   @After
   subroutine tear_down()
      integer :: status, rc

      call ESMF_TimeSet(start_time, _RC)
      call ESMF_TimeIntervalSet(timestep, _RC)
      call ESMF_ClockDestroy(clock, _RC)
      call ESMF_TimeSet(time, _RC)
      call ESMF_TimeIntervalSet(time_interval, _RC)
      call ESMF_TimeSet(time, _RC)
      call ESMF_TimeSet(update_time, _RC)
      call ESMF_TimeSet(reference_time, _RC)
      call ESMF_Finalize(_RC)

   end subroutine tear_down

   subroutine make_esmf_time(fields, time, time_only, rc)
      integer, intent(in) :: fields(:)
      type(ESMF_Time), intent(inout) :: time
      logical, optional, intent(in) :: time_only
      integer, optional, intent(out) :: rc
      integer :: status, n(6), i, k

      status = 0
      k = size(fields)
      if(k == 0 .or. k > size(n)) status = -1
      _VERIFY(status)
      n = 0
      i = 1
      if(present(time_only)) then
         if(time_only) i = 4
      end if
      n(i:i+k-1) = fields(1:k)
      call ESMF_TimeSet(time, yy=n(1), mm=n(2), dd=n(3), h=n(4), m=n(5), s=n(6), _RC)
      _RETURN(_SUCCESS)
         
   end subroutine make_esmf_time

   @Test
   subroutine test_get_adjusted_time
      type(ExtDataPointerUpdate) :: ex
      integer :: status, rc
      character(len=32) :: offset_string
      type(ESMF_TimeInterval) :: offset
      integer :: ios
      integer, parameter :: OFFSET_IN_SECONDS = 300
      logical :: actual_matches_expected

      write(offset_string, fmt='("PT", I03, "S")', iostat=ios) OFFSET_IN_SECONDS
      _VERIFY(ios)
      call ESMF_TimeIntervalSet(offset, s=OFFSET_IN_SECONDS, _RC)
      call ex%create_from_parameters(UPDATE_TIMESTRING, UPDATE_FREQ_STRING, offset_string, time, clock, _RC)
      actual_matches_expected = (ex%get_adjusted_time(time) == (time + offset))
      @assertTrue(actual_matches_expected, 'Adjusted time does match expected time.')

   end subroutine test_get_adjusted_time

   @Test
   subroutine test_create_from_parameters_string_positive()
      type(ExtDataPointerUpdate) :: ex
      integer :: status, rc
      character(len=32) :: offset_string
      integer, parameter :: OFFSET_IN_SECONDS = 300
      type(ESMF_TimeInterval) :: offset
      integer :: ios
      logical, parameter :: FIRST_TIME = .TRUE.
      logical :: actual_matches_expected, do_update
      type(ESMF_Time) :: use_time, current_time

      write(offset_string, fmt='("PT", I03, "S")', iostat=ios) OFFSET_IN_SECONDS
      _VERIFY(ios)
      call ESMF_TimeIntervalSet(offset, s=OFFSET_IN_SECONDS, _RC)
      call ex%create_from_parameters(UPDATE_TIMESTRING, UPDATE_FREQ_STRING, offset_string, time, clock, _RC)
      call ex%check_update(do_update, use_time, current_time, FIRST_TIME, _RC)
      actual_matches_expected = (use_time == reference_time+offset)
      @assertTrue(actual_matches_expected, 'use_time does not match expected time.')

   end subroutine test_create_from_parameters_string_positive

   @Test
   subroutine test_create_from_parameters_string_negative()
      type(ExtDataPointerUpdate) :: ex
      integer :: status, rc
      character(len=32) :: offset_string
      integer, parameter :: OFFSET_IN_SECONDS = 300
      type(ESMF_TimeInterval) :: offset
      integer :: ios
      logical, parameter :: FIRST_TIME = .TRUE.
      logical :: actual_matches_expected, do_update
      type(ESMF_Time) :: use_time, current_time

      write(offset_string, fmt='("PT", I03, "S")', iostat=ios) OFFSET_IN_SECONDS
      offset_string = '-' // offset_string
      _VERIFY(ios)
      call ESMF_TimeIntervalSet(offset, s=-OFFSET_IN_SECONDS, _RC)
      call ex%create_from_parameters(UPDATE_TIMESTRING, UPDATE_FREQ_STRING, offset_string, time, clock, _RC)
      call ex%check_update(do_update, use_time, current_time, FIRST_TIME, _RC)
      actual_matches_expected = (use_time == reference_time-offset)
      @assertTrue(actual_matches_expected, 'use_time does not match expected time.')

   end subroutine test_create_from_parameters_string_negative

   @Test
   subroutine test_create_from_parameters_heartbeat_positive()
      type(ExtDataPointerUpdate) :: ex
      integer :: status, rc
      character(len=*), parameter :: OFFSET_STRING = HEARTBEAT_STRING
      type(ESMF_TimeInterval) :: offset
      logical, parameter :: FIRST_TIME = .TRUE.
      logical :: actual_matches_expected, do_update
      type(ESMF_Time) :: use_time, current_time

      offset = timestep
      call ex%create_from_parameters(UPDATE_TIMESTRING, UPDATE_FREQ_STRING, OFFSET_STRING, time, clock, _RC)
      call ex%check_update(do_update, use_time, current_time, FIRST_TIME, _RC)
      actual_matches_expected = (use_time == reference_time+offset)
      @assertTrue(actual_matches_expected, 'use_time does not match expected time.')

   end subroutine test_create_from_parameters_heartbeat_positive

   @Test
   subroutine test_create_from_parameters_heartbeat_negative()
      type(ExtDataPointerUpdate) :: ex
      integer :: status, rc
      character(len=*), parameter :: OFFSET_STRING = '-' // HEARTBEAT_STRING
      type(ESMF_TimeInterval) :: offset
      logical, parameter :: FIRST_TIME = .TRUE.
      logical :: actual_matches_expected, do_update
      type(ESMF_Time) :: use_time, current_time

      offset = -timestep
      call ex%create_from_parameters(UPDATE_TIMESTRING, UPDATE_FREQ_STRING, OFFSET_STRING, time, clock, _RC)
      call ex%check_update(do_update, use_time, current_time, FIRST_TIME, _RC)
      actual_matches_expected = (use_time == reference_time+offset)
      @assertTrue(actual_matches_expected, 'use_time does not match expected time.')

   end subroutine test_create_from_parameters_heartbeat_negative

end module Test_ExtDataUpdatePointer
