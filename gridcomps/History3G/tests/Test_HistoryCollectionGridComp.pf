#include "MAPL_TestErr.h"
#define CAT2(A, B) A//B
#define CAT(A, B, C) CAT2(CAT2(A,B), C)
module Test_HistoryCollectionGridComp

   use pfunit
   use mapl3g_HistoryCollectionGridComp_private
   use esmf
   use gFTL2_StringVector
   use mapl3g_output_info_set
   implicit none

contains

   !@Test
   subroutine test_make_geom()
      type(ESMF_HConfig) :: hconfig
      type(ESMF_Geom) :: geom
      type(ESMF_Grid) :: grid
      integer :: rank
      integer :: status

      hconfig = ESMF_HConfigCreate(content= &
         "{geom: {class: latlon, im_world: 12, jm_world: 13, pole: PC, " // &
         "dateline: DC, nx: 1, ny: 1}}", _RC)
      geom = make_geom(hconfig, _RC)
      call ESMF_GeomGet(geom, grid=grid, rank=rank, _RC)
      @assert_that(rank, is(2))

      call ESMF_HConfigDestroy(hconfig, _RC)
      call ESMF_GridDestroy(grid, nogarbage=.true., _RC)
      call ESMF_GeomDestroy(geom, _RC)

   end subroutine test_make_geom

   !@Test
   subroutine test_create_output_bundle()
      type(ESMF_HConfig) :: hconfig_geom, hconfig_hist
      type(ESMF_Geom) :: geom
      type(ESMF_Grid) :: grid
      integer :: rank,fieldCount
      integer :: status
      logical :: found
      type(ESMF_State) :: state, substate
      type(ESMF_FieldBundle) :: bundle
      type(ESMF_Field) :: field

      hconfig_geom = ESMF_HConfigCreate(content= &
         "{geom: {class: latlon, im_world: 14, jm_world: 13, pole: PC, " // &
         "dateline: DC, nx: 1, ny: 1}}", _RC)
      geom = make_geom(hconfig_geom, _RC)
      call ESMF_GeomGet(geom, grid=grid, _RC)

      field = ESMF_FieldCreate(grid, ESMF_TYPEKIND_R4, name="E_1", _RC)
      substate = ESMF_StateCreate(fieldList=[field], name= "DYN", _RC)
      state = ESMF_Statecreate(nestedStateList=[substate],_RC)

      hconfig_hist = ESMF_HConfigCreate(content= &
         "{var_list: {E1: {expr: DYN.E_1}}}", _RC)
 
      bundle = create_output_bundle(hconfig_hist, state, _RC)
      call ESMF_FieldBundleGet(bundle, fieldCount=fieldCount, _RC)
      @assert_that(fieldCount, is(1))
      call ESMF_FieldBundleGet(bundle, "E1", isPresent=found, _RC)
      @assert_that(found, is(true()))
      
      call ESMF_HConfigDestroy(hconfig_geom, _RC)
      call ESMF_HConfigDestroy(hconfig_hist, _RC)

      call ESMF_FieldBundleGet(bundle, "E1", field=field, _RC)
      call ESMF_FieldDestroy(field, nogarbage=.true., _RC)
      call ESMF_FieldBundleDestroy(bundle, nogarbage=.true. ,_RC)

      call ESMF_StateGet(state, "DYN/E_1", field, _RC)
      call ESMF_FieldDestroy(field, nogarbage=.true., _RC)
      call ESMF_StateDestroy(state, nogarbage=.true., _RC)

      call ESMF_GridDestroy(grid, nogarbage=.true., _RC)
      call ESMF_GeomDestroy(geom, _RC)

   end subroutine test_create_output_bundle

   !@Test
   subroutine test_replace_delimiter()
      character(len=:), allocatable :: d, r
      character(len=*), parameter :: A = 'bread'
      character(len=*), parameter :: B = 'butter'

      d = '.'
      r = '/'
      @assertEqual(CAT(A,r,B), replace_delimiter(CAT(A,d,B), d, r), 'Default - ' // make_message(d, r)) 
      @assertEqual(CAT(A,r,B), replace_delimiter(CAT(A,d,B)), 'No args')

      d = '@'
      r = '*'
      @assertEqual(CAT(A,r,B), replace_delimiter(CAT(A,d,B), d, r), make_message(d, r))
      
      d = '::'
      r = '---'
      @assertEqual(CAT(A,r,B), replace_delimiter(CAT(A,d,B), d, r), make_message(d, r)) 
      
      d = ''
      @assertEqual(CAT(A,r,B), replace_delimiter(CAT(A,r,B), d, r), make_message(d, r)) 

      d = '.'
      r = ''
      @assertEqual(CAT(A,d,B), replace_delimiter(CAT(A,d,B), d, r), make_message(d, r)) 

      @assertEqual('', replace_delimiter('', d, r), make_message(d, r)) 

   contains

         function make_message(delimiter, replacement) result(message)
            character(len=:), allocatable :: message
            character(len=*), intent(in) :: delimiter, replacement

            message = 'Args: ("' // delimiter // '", "' // replacement // '") - '

         end function make_message

   end subroutine test_replace_delimiter

   !@Test
   subroutine test_get_expression_variables()
      type(StringVector) :: variables
      type(StringVectorIterator) :: iter
      character(len=:), allocatable :: expected(:), variable
      integer :: status, i

      i = 0
      expected = [character(len=16) :: 'GC1/F1', 'GC2/F2']
      variables = get_expression_variables('GC1.F1 + GC2.F2', _RC)

      iter = variables%begin()
      do while(iter /= variables%end())
         i = i + 1
         variable = iter%of()
         @assertEqual(expected(i), variable, 'Expected does not match actual.')
         call iter%next()
      end do

   end subroutine test_get_expression_variables

   !@Test
   subroutine test_parse_item_common()
      type(ESMF_HConfig) :: hconfig
      type(ESMF_HConfigIter) :: hc_iter, hc_iter_begin, hc_iter_end
      character(len=:), allocatable :: expression, item_name, content, expected_name, expected_expression
      integer :: status

      expected_name = 'A_1'
      expected_expression = 'GC1.F1+GC2.F2'

      content = '{' // expected_name // ': {expr: ' // expected_expression // '}}'
!      content = '{A_1: {expr: GC1.F1+GC2.F2}}' 
      hconfig = ESMF_HConfigCreate(content=content, _RC)

      hc_iter_begin = ESMF_HConfigIterBegin(hconfig, _RC)
      hc_iter_end = ESMF_HConfigIterEnd(hconfig, _RC)
      hc_iter = hc_iter_begin

      do while (ESMF_HConfigIterLoop(hc_iter, hc_iter_begin, hc_iter_end, rc=status))
         @assertEqual(0, status, 'Nonzero status returned.')
         call parse_item_common(hc_iter, item_name, expression)
         @assertEqual(expected_name, item_name, 'Actual item_name does not match actual item_name.')
         @assertEqual(expected_expression, expression, 'Actual expression does not match actual expression')
      end do

   end subroutine test_parse_item_common

   subroutine test_set_start_stop_time()
      type(ESMF_HConfig) :: hconfig
      type(ESMF_Time) :: time,start_stop_time(2)
      integer :: status
      type(ESMF_Time) :: start_time, stop_time
      type(ESMF_TimeInterval) :: dt
      type(ESMF_Clock) :: clock

      call ESMF_TimeIntervalSet(dt, h=1, _RC)
      call ESMF_TimeSet(start_time, timeString="2000-04-03T21:00:00", _RC)
      call ESMF_TimeSet(stop_time, timeString="2000-04-22T21:00:00", _RC)
      clock = ESMF_ClockCreate(timeStep=dt, startTime=start_time, stopTime=stop_time, _RC)

      hconfig = ESMF_HConfigCreate(content = &
        "{time_spec: {frequency: PT3H}}", _RC)

      start_stop_time = set_start_stop_time(clock, hconfig, _RC)
      @assert_that(start_time == start_stop_time(1), is(true()))
      @assert_that(stop_time == start_stop_time(2), is(true()))
 
      hconfig = ESMF_HConfigCreate(content = &
        "{time_spec: {start: 2000-04-14T21:00:00, stop: 2000-04-15T21:00:00}}", _RC)
      call ESMF_TimeSet(start_time, timeString="2000-04-14T21:00:00", _RC)
      call ESMF_TimeSet(stop_time, timeString="2000-04-15T21:00:00", _RC)

      start_stop_time = set_start_stop_time(clock, hconfig, _RC)
      @assert_that(start_time == start_stop_time(1), is(true()))
      @assert_that(stop_time == start_stop_time(2), is(true()))

   end subroutine test_set_start_stop_time

   !@Test
   subroutine test_create_output_alarm()
      type(ESMF_HConfig) :: hconfig
      type(ESMF_Time) :: time,start_stop_time(2)
      integer :: status
      type(ESMF_Time) :: start_time, stop_time
      type(ESMF_TimeInterval) :: dt
      type(ESMF_Clock) :: clock
      type(ESMF_Alarm) :: alarm
      logical :: is_ringing
      type(ESMF_Time) currTime
      character(len=:), allocatable :: comp_name

      comp_name = "coll1"
      call ESMF_TimeIntervalSet(dt, h=1, _RC)
      call ESMF_TimeSet(start_time, timeString="2000-04-03T21:00:00", _RC)
      call ESMF_TimeSet(stop_time, timeString="2000-04-22T21:00:00", _RC)
      clock = ESMF_ClockCreate(timeStep=dt, startTime=start_time, stopTime=stop_time, _RC)
      hconfig = ESMF_HConfigCreate(content = &
        "{time_spec: {frequency: PT3H}}", _RC)

      call create_output_alarm(clock, hconfig, comp_name, _RC)
      call ESMF_ClockGetAlarm(clock, comp_name//"_write_alarm", alarm, _RC)
     
      call ESMF_ClockAdvance(clock, _RC)
      is_ringing = ESMF_AlarmIsRinging(alarm, _RC) 
      @assert_that(is_ringing, is(false()))

      call ESMF_ClockAdvance(clock, _RC)
      is_ringing = ESMF_AlarmIsRinging(alarm, _RC) 
      @assert_that(is_ringing, is(false()))

      call ESMF_ClockAdvance(clock, _RC) 
      is_ringing = ESMF_AlarmIsRinging(alarm, _RC) 
      @assert_that(is_ringing, is(true()))
 
   end subroutine test_create_output_alarm

   @Test
   subroutine test_get_output_info_bundle()
      type(ESMF_HConfig) :: hconfig_geom, hconfig_hist
      type(ESMF_Geom) :: geom
      type(ESMF_Grid) :: grid
      integer :: rank,fieldCount
      integer :: status
      logical :: found
      type(ESMF_State) :: state, substate
      type(ESMF_FieldBundle) :: bundle
      type(ESMF_Field) :: field
      type(OutputInfoSet) :: out_set

      !call ESMF_Initialize(_RC)
      hconfig_geom = ESMF_HConfigCreate(content= &
         "{geom: {class: latlon, im_world: 14, jm_world: 13, pole: PC, " // &
         "dateline: DC, nx: 1, ny: 1}}", _RC)
      geom = make_geom(hconfig_geom, _RC)
      call ESMF_GeomGet(geom, grid=grid, _RC)

      field = ESMF_FieldCreate(grid, ESMF_TYPEKIND_R4, name="E_1", _RC)
      substate = ESMF_StateCreate(fieldList=[field], name= "DYN", _RC)
      state = ESMF_Statecreate(nestedStateList=[substate],_RC)

      hconfig_hist = ESMF_HConfigCreate(content= &
         "{var_list: {E1: {expr: DYN.E_1}}}", _RC)
 
      bundle = create_output_bundle(hconfig_hist, state, _RC)
      out_set = get_output_info_bundle(bundle, _RC)
      !@assertEqual(1, out_set%size(), 'There should be one element.')
!      call ESMF_HConfigDestroy(hconfig_hist, _RC)
      !call ESMF_FieldBundleDestroy(bundle, nogarbage=.true. ,_RC)
      !call ESMF_FieldDestroy(field, nogarbage=.true., _RC)
      !call ESMF_StateDestroy(state, nogarbage=.true., _RC)
      !call ESMF_GridDestroy(grid, nogarbage=.true., _RC)
      !call ESMF_GeomDestroy(geom, _RC)
      !call ESMF_HConfigDestroy(hconfig_geom, _RC)
      !call ESMF_Finalize()

   end subroutine test_get_output_info_bundle

end module Test_HistoryCollectionGridComp
