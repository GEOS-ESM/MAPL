#include "MAPL_TestErr.h"
module Test_ESMF_Time_Utilities
   use mapl3g_ESMF_Time_Utilities
   use esmf
   use funit
   implicit none

   character(len=*), parameter :: SHOULD = 'The intervals should be compatible.'

contains

   @Test
   subroutine test_interval_is_all_zero()
      type(ESMF_TimeInterval) :: interval
      logical :: all_zero
      integer :: status

      call ESMF_TimeIntervalSet(interval, s=0, _RC)
      call interval_is_all_zero(interval, all_zero, _RC)
      @assertTrue(all_zero, 'The interval should be all zero.')

   end subroutine test_interval_is_all_zero

   @Test
   subroutine test_interval_is_not_all_zero()
      type(ESMF_TimeInterval) :: interval
      logical :: all_zero
      integer :: status

      call ESMF_TimeIntervalSet(interval, s=1, _RC)
      call interval_is_all_zero(interval, all_zero, _RC)
      @assertFalse(all_zero, 'The interval should not be all zero.')

   end subroutine test_interval_is_not_all_zero

   @Test
   subroutine test_1h_30m()
      type(ESMF_TimeInterval) :: interval1, interval2, offset
      integer :: status
      logical :: compatible

      call ESMF_TimeIntervalSet(interval1, h=1, _RC)
      call ESMF_TimeIntervalSet(interval2, m=30, _RC)
      call ESMF_TimeIntervalSet(offset, h=2, _RC)
      call intervals_and_offset_are_compatible(interval1, interval2, compatible, offset=offset, _RC)
      @assertTrue(compatible, 'The intervals and offset should be compatible.')

   end subroutine test_1h_30m

   @Test
   subroutine test_3d_1d()
      type(ESMF_TimeInterval) :: larger
      type(ESMF_TimeInterval) :: smaller
      logical :: compatible
      integer :: status

      call ESMF_TimeIntervalSet(larger, d=3, _RC)
      call ESMF_TimeIntervalSet(smaller, d=1, _RC)
      call intervals_and_offset_are_compatible(larger, smaller, compatible, _RC)
      @assertTrue(compatible, SHOULD)

   end subroutine test_3d_1d

   @Test
   subroutine test_1yy_1d()
      type(ESMF_TimeInterval) :: larger
      type(ESMF_TimeInterval) :: smaller
      logical :: compatible
      integer :: status

      call ESMF_TimeIntervalSet(larger, yy=1, _RC)
      call ESMF_TimeIntervalSet(smaller, d=1, _RC)
      call intervals_and_offset_are_compatible(larger, smaller, compatible, _RC)
      @assertFalse(compatible, 'The interval types are inconsistent.')

   end subroutine test_1yy_1d

   @Test
   subroutine test_1d_6h_12h()
      type(ESMF_TimeInterval) :: larger
      type(ESMF_TimeInterval) :: smaller
      type(ESMF_TimeInterval) :: offset
      logical :: compatible
      integer :: status

      call ESMF_TimeIntervalSet(larger, d=1, _RC)
      call ESMF_TimeIntervalSet(smaller, h=6, _RC)
      call ESMF_TimeIntervalSet(offset, h = 12, _RC)
      call intervals_and_offset_are_compatible(larger, smaller, compatible, offset=offset, _RC)
      @assertTrue(compatible, 'The intervals and offset should be compatible.')

   end subroutine test_1d_6h_12h

   @Test
   subroutine test_12h_2h_3h()
      type(ESMF_TimeInterval) :: larger
      type(ESMF_TimeInterval) :: smaller
      type(ESMF_TimeInterval) :: offset
      logical :: compatible
      integer :: status

      call ESMF_TimeIntervalSet(larger, h = 12, _RC)
      call ESMF_TimeIntervalSet(smaller, h = 2, _RC)
      call ESMF_TimeIntervalSet(offset, h = 3, _RC)
      call intervals_and_offset_are_compatible(larger, smaller, compatible, offset=offset, _RC)
      @assertFalse(compatible, 'The smaller interval does not divide the offset evenly.')

   end subroutine test_12h_2h_3h

   @Test
   subroutine test_6h_4h()
      type(ESMF_TimeInterval) :: larger
      type(ESMF_TimeInterval) :: smaller
      logical :: compatible
      integer :: status

      call ESMF_TimeIntervalSet(larger, h=6, _RC)
      call ESMF_TimeIntervalSet(smaller, h=4, _RC)
      call intervals_and_offset_are_compatible(larger, smaller, compatible, _RC)
      @assertFalse(compatible, 'The smaller interval does not divide the larger interval evenly.')

   end subroutine test_6h_4h

   @Test
   subroutine test_1yy1mm_1yy1d()
      type(ESMF_TimeInterval) :: larger
      type(ESMF_TimeInterval) :: smaller
      logical :: compatible
      integer :: status

      call ESMF_TimeIntervalSet(larger, yy=1, mm=1, d=0, h=0, _RC)
      call ESMF_TimeIntervalSet(smaller, yy=1, mm=0, d=1, h=0, _RC)
      call intervals_and_offset_are_compatible(larger, smaller, compatible, _RC)
      @assertFalse(compatible, 'The interval types are inconsistent.')

   end subroutine test_1yy1mm_1yy1d
   
   @Test
   subroutine test_2d_1mm()
      type(ESMF_TimeInterval) :: larger
      type(ESMF_TimeInterval) :: smaller
      logical :: compatible
      integer :: status

      call ESMF_TimeIntervalSet(larger, d=2, _RC)
      call ESMF_TimeIntervalSet(smaller, mm=1, _RC)
      call intervals_and_offset_are_compatible(larger, smaller, compatible, _RC)
      @assertFalse(compatible, 'The interval types are inconsistent.')

   end subroutine test_2d_1mm

   @Test
   subroutine test_3yy_1yy_2yy()
      type(ESMF_TimeInterval) :: larger
      type(ESMF_TimeInterval) :: smaller
      type(ESMF_TimeInterval) :: offset
      logical :: compatible
      integer :: status

      call ESMF_TimeIntervalSet(larger, yy=3, _RC)
      call ESMF_TimeIntervalSet(smaller, yy=1, _RC)
      call ESMF_TimeIntervalSet(offset, yy=2, _RC)
      call intervals_and_offset_are_compatible(larger, smaller, compatible, offset=offset, _RC)
      @assertTrue(compatible, SHOULD)

   end subroutine test_3yy_1yy_2yy

   @Test
   subroutine test_3mm_1mm_2mm()
      type(ESMF_TimeInterval) :: larger
      type(ESMF_TimeInterval) :: smaller
      type(ESMF_TimeInterval) :: offset
      logical :: compatible
      integer :: status

      call ESMF_TimeIntervalSet(larger, mm=3, _RC)
      call ESMF_TimeIntervalSet(smaller, mm=1, _RC)
      call ESMF_TimeIntervalSet(offset, mm=2, _RC)
      call intervals_and_offset_are_compatible(larger, smaller, compatible, offset=offset, _RC)
      @assertTrue(compatible, SHOULD)

   end subroutine test_3mm_1mm_2mm

end module Test_ESMF_Time_Utilities
