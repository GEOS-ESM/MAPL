#include "MAPL_TestErr.h"
module Test_ESMF_Time_Utilities
   use mapl3g_ESMF_Time_Utilities
   use esmf
   use funit
   implicit none

contains

   @Test
   subroutine test_units_in()
      type(ESMF_TimeInterval) :: interval
      integer :: status
      logical, allocatable :: has_units(:)
      integer(kind=ESMF_KIND_I4) :: units(6)

      units = [0, 3, 0, 1, 4, 7]
      call ESMF_TimeIntervalSet(interval, yy=units(1), mm=units(2), d=units(3), &
         & h=units(4), m=units(5), s=units(6), _RC)
      has_units = units_in(interval, _RC)
      @assertEqual(units /= 0, has_units)

   end subroutine test_units_in

   @Test
   subroutine test_can_compare_intervals()
      type(ESMF_TimeInterval) :: interval1, interval2
      integer :: status
      logical :: can_compare

      call ESMF_TimeIntervalSet(interval1, d=3, _RC)
      call ESMF_TimeIntervalSet(interval2, h=7, _RC)
      can_compare = can_compare_intervals(interval1, interval2, _RC)
      @assertTrue(can_compare, 'The intervals can be compared.')

      call ESMF_TimeIntervalSet(interval1, mm=2, _RC)
      can_compare = can_compare_intervals(interval1, interval2, _RC)
      @assertFalse(can_compare, 'The intervals cannot be compared.')

      can_compare = can_compare_intervals(interval2, interval1, _RC)
      @assertFalse(can_compare, 'The intervals cannot be compared.')

      call ESMF_TimeIntervalSet(interval1, yy=2, _RC)
      can_compare = can_compare_intervals(interval2, interval1, _RC)
      @assertFalse(can_compare, 'The intervals cannot be compared.')

   end subroutine test_can_compare_intervals

   @Test
   subroutine test_get_zero()
      type(ESMF_TimeInterval) :: interval
      integer(ESMF_KIND_I4) :: ns
      integer(ESMF_KIND_I4), parameter :: EXPECTED_NS = 0
      integer(ESMF_KIND_I4), parameter :: INITIAL_NS = 1
      integer :: status

      call ESMF_TimeIntervalSet(interval, ns=INITIAL_NS, _RC)
      interval = zero_time_interval()
      call ESMF_TimeIntervalGet(interval, ns=ns, _RC)
      @assertEqual(EXPECTED_NS, ns, 'Interval is not zero.')

   end subroutine test_get_zero

   @Test
   subroutine test_intervals_are_compatible()
      type(ESMF_TimeInterval) :: larger
      type(ESMF_TimeInterval) :: smaller
      integer(kind=ESMF_KIND_I4), parameter :: YY = 3
      integer(kind=ESMF_KIND_I4), parameter :: MM = 3
      integer(kind=ESMF_KIND_I4), parameter :: DD = 3
      integer(kind=ESMF_KIND_I4), parameter :: H = 3
      logical :: compatible
      integer :: status

      call ESMF_TimeIntervalSet(larger, d=3*DD, _RC)
      call ESMF_TimeIntervalSet(smaller, d=DD, _RC)
      compatible = intervals_are_compatible(larger, smaller, _RC)
      @assertTrue(compatible, 'The intervals are compatible.')

      compatible = intervals_are_compatible(smaller, larger, _RC)
      @assertFalse(compatible, 'The larger unit must come first.')

      call ESMF_TimeIntervalSet(smaller, d=2*DD, _RC)
      compatible = intervals_are_compatible(larger, smaller, _RC)
      @assertFalse(compatible, 'The smaller interval does not divide the larger interval evenly.')

   end subroutine test_intervals_are_compatible

   @Test
   subroutine test_times_and_intervals_are_compatible()
      type(ESMF_TimeInterval) :: larger
      type(ESMF_TimeInterval) :: smaller
      type(ESMF_Time) :: time1
      type(ESMF_Time) :: time2
      logical :: compatible
      integer :: status

      call ESMF_TimeSet(time1, yy=1582, mm=10, dd=16, h=7, _RC)
      call ESMF_TimeSet(time2, yy=1582, mm=10, dd=15, h=19, _RC)
      call ESMF_TimeIntervalSet(larger, d=1, _RC)
      call ESMF_TimeIntervalSet(smaller, h = 6, _RC)
      compatible = times_and_intervals_are_compatible(time1, time2, larger, smaller, _RC)
      @assertTrue(compatible, 'The times and intervals are compatible.')

      call ESMF_TimeSet(time2, yy=1582, mm=10, dd=15, h=18, _RC)
      compatible = times_and_intervals_are_compatible(time1, time2, larger, smaller, _RC)
      @assertFalse(compatible, 'The time difference is not evenly divisible by the smaller interval.')

      call ESMF_TimeSet(time1, yy=1582, mm=10, dd=16, h=18, _RC)
      call ESMF_TimeIntervalSet(larger, h=6, _RC)
      call ESMF_TimeIntervalSet(smaller, h=4, _RC)
      compatible = times_and_intervals_are_compatible(time1, time2, larger, smaller, _RC)
      @assertFalse(compatible, 'The larger interval is not evenly divisible by the smaller interval.')
      call ESMF_TimeIntervalSet(larger, mm=1, _RC)
      call ESMF_TimeIntervalSet(smaller, d=1, _RC)
      compatible = times_and_intervals_are_compatible(time1, time2, larger, smaller, _RC)
      @assertFalse(compatible, 'Larger interval cannot include months.')

      call ESMF_TimeIntervalSet(larger, d=90, _RC)
      call ESMF_TimeIntervalSet(smaller, mm=1, _RC)
      compatible = times_and_intervals_are_compatible(time1, time2, larger, smaller, _RC)
      @assertFalse(compatible, 'Smaller interval cannot include months.')

      call ESMF_TimeIntervalSet(larger, yy=1, _RC)
      call ESMF_TimeIntervalSet(smaller, d=1, _RC)
      compatible = times_and_intervals_are_compatible(time1, time2, larger, smaller, _RC)
      @assertFalse(compatible, 'Larger interval cannot include years.')

      call ESMF_TimeIntervalSet(larger, d=365, _RC)
      call ESMF_TimeIntervalSet(smaller, yy=1, _RC)
      compatible = times_and_intervals_are_compatible(time1, time2, larger, smaller, _RC)
      @assertFalse(compatible, 'Smaller interval cannot include years.')

   end subroutine test_times_and_intervals_are_compatible

end module Test_ESMF_Time_Utilities
