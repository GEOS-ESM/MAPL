module Test_mapl3hconfig_get_private
   use mapl3hconfig_get_private
   use ESMF
   use pfunit

   implicit none

   ! error message stubs
   character(len=*), parameter :: ERROR_EXPECTED_MESSAGE_BLANK = 'expected_message is blank.'
   character(len=*), parameter :: ERROR_GET_HCONFIG_FAILED = 'get_HConfig failed.'
   character(len=*), parameter :: ERROR_ADD_FAIL = 'Add failed.'
   character(len=*), parameter :: ERROR_NOT_FOUND = 'Find failed for: '
   character(len=*), parameter :: ERROR_MESSAGE_MISMATCH = 'Message does not match.'
   character, parameter :: SPACE = ' '

   ! instance variables
   logical :: hconfig_is_created = .FALSE.
   type(ESMF_HConfig) :: hconfig

contains

   @Test
   subroutine test_get_i4()
      character(len=*), parameter :: KEY = 'inv_alpha'
      character(len=*), parameter :: TYPESTRING = 'I4'
      character(len=*), parameter :: VALUESTRING = '137'
      integer(kind=ESMF_KIND_I4), parameter :: EXPECTED = 137
      integer(kind=ESMF_KIND_I4) :: actual
      character(len=MAXSTRLEN) :: expected_message
      character(len=:), allocatable :: message
      logical :: found
      integer :: status

      expected_message = make_expected_message(TYPESTRING, KEY, VALUESTRING)
      @assertFalse(is_blank(expected_message), ERROR_EXPECTED_MESSAGE_BLANK)
      call ESMF_HConfigAdd(hconfig, EXPECTED, addKeyString=KEY, rc=status)
      @assertEqual(0, status, ERROR_ADD_FAIL)
      call get_value(hconfig, actual, found, message, KEY, rc=status)
      @assertEqual(0, status, ERROR_GET_HCONFIG_FAILED)
      @assertTrue(found, ERROR_NOT_FOUND // KEY)
      @assertTrue(actual == EXPECTED, make_mismatch_error_message(actual, EXPECTED)) 
      @assertEqual(expected_message, message, ERROR_MESSAGE_MISMATCH)

   end subroutine test_get_i4

   @Test
   subroutine test_get_i8()
      character(len=*), parameter :: KEY = 'num_h_on_pinhead'
      character(len=*), parameter :: TYPESTRING = 'I8'
      character(len=*), parameter :: VALUESTRING = '50000000000'
      integer(kind=ESMF_KIND_I8), parameter :: EXPECTED = 50000000000
      integer(kind=ESMF_KIND_I8) :: actual
      character(len=MAXSTRLEN) :: expected_message
      character(len=:), allocatable :: message
      logical :: found
      integer :: status

      expected_message = make_expected_message(TYPESTRING, KEY, VALUESTRING)
      @assertFalse(is_blank(expected_message), ERROR_EXPECTED_MESSAGE_BLANK)
      call ESMF_HConfigAdd(hconfig, EXPECTED, addKeyString=KEY, rc=status)
      @assertEqual(0, status, ERROR_ADD_FAIL)
      call get_value(hconfig, actual, found, message, KEY, rc=status)
      @assertEqual(0, status, ERROR_GET_HCONFIG_FAILED)
      @assertTrue(found, ERROR_NOT_FOUND // KEY)
      @assertTrue(actual == EXPECTED, make_mismatch_error_message(actual, EXPECTED)) 
      @assertEqual(expected_message, message, ERROR_MESSAGE_MISMATCH)

   end subroutine test_get_i8
   
   @Test
   subroutine test_get_r4()
      character(len=*), parameter :: KEY = 'plank_mass'
      character(len=*), parameter :: TYPESTRING = 'R4'
      character(len=*), parameter :: VALUESTRING = '0.18590000E-08'
      real(kind=ESMF_KIND_R4), parameter :: EXPECTED =   1.8590000E-9_ESMF_KIND_R4
      real(kind=ESMF_KIND_R4) :: actual
      character(len=MAXSTRLEN) :: expected_message
      character(len=:), allocatable :: message
      logical :: found
      integer :: status

      expected_message = make_expected_message(TYPESTRING, KEY, VALUESTRING)
      @assertFalse(is_blank(expected_message), ERROR_EXPECTED_MESSAGE_BLANK)
      call ESMF_HConfigAdd(hconfig, EXPECTED, addKeyString=KEY, rc=status)
      @assertEqual(0, status, ERROR_ADD_FAIL)
      call get_value(hconfig, actual, found, message, KEY, rc=status)
      @assertEqual(0, status, ERROR_GET_HCONFIG_FAILED)
      @assertTrue(found, ERROR_NOT_FOUND // KEY)
      @assertTrue(actual == EXPECTED, make_mismatch_error_message(actual, EXPECTED)) 
      @assertEqual(expected_message, message, ERROR_MESSAGE_MISMATCH)

   end subroutine test_get_r4
   
   @Test
   subroutine test_get_r8()
      character(len=*), parameter :: KEY = 'mu_mass'
      character(len=*), parameter :: TYPESTRING = 'R8'
      character(len=*), parameter :: VALUESTRING =   '-0.9284764704320000E-23'
      real(kind=ESMF_KIND_R8), parameter :: EXPECTED = -9.284764704320000E-24_ESMF_KIND_R8
      real(kind=ESMF_KIND_R8) :: actual
      character(len=MAXSTRLEN) :: expected_message
      character(len=:), allocatable :: message
      logical :: found
      integer :: status

      expected_message = make_expected_message(TYPESTRING, KEY, VALUESTRING)
      @assertFalse(is_blank(expected_message), ERROR_EXPECTED_MESSAGE_BLANK)
      call ESMF_HConfigAdd(hconfig, EXPECTED, addKeyString=KEY, rc=status)
      @assertEqual(0, status, ERROR_ADD_FAIL)
      call get_value(hconfig, actual, found, message, KEY, rc=status)
      @assertEqual(0, status, ERROR_GET_HCONFIG_FAILED)
      @assertTrue(found, ERROR_NOT_FOUND // KEY)
      @assertTrue(actual == EXPECTED, make_mismatch_error_message(actual, EXPECTED)) 
      @assertEqual(expected_message, message, ERROR_MESSAGE_MISMATCH)

   end subroutine test_get_r8

   @Test
   subroutine test_get_logical()
      character(len=*), parameter :: KEY = 'p_or_np'
      character(len=*), parameter :: TYPESTRING = 'L'
      character(len=*), parameter :: VALUESTRING = 'T'
      logical, parameter :: EXPECTED = .TRUE.
      logical :: actual
      character(len=MAXSTRLEN) :: expected_message
      character(len=:), allocatable :: message
      logical :: found
      integer :: status

      expected_message = make_expected_message(TYPESTRING, KEY, VALUESTRING)
      @assertFalse(is_blank(expected_message) > 0, ERROR_EXPECTED_MESSAGE_BLANK)
      call ESMF_HConfigAdd(hconfig, EXPECTED, addKeyString=KEY, rc=status)
      @assertEqual(0, status, ERROR_ADD_FAIL)
      call get_value(hconfig, actual, found, message, KEY, rc=status)
      @assertEqual(0, status, ERROR_GET_HCONFIG_FAILED)
      @assertTrue(found, ERROR_NOT_FOUND // KEY)
      @assertTrue(actual == EXPECTED, make_mismatch_error_message(actual, EXPECTED)) 
      @assertEqual(expected_message, message, ERROR_MESSAGE_MISMATCH)

   end subroutine test_get_logical

   @Test
   subroutine test_get_string()
      character(len=*), parameter :: KEY = 'newton'
      character(len=*), parameter :: TYPESTRING = 'CH'
      character(len=*), parameter :: VALUESTRING = 'Fg = Gm1m2/r^2'
      character(len=*), parameter :: EXPECTED = 'Fg = Gm1m2/r^2'
      character(len=MAXSTRLEN) :: actual
      character(len=MAXSTRLEN) :: expected_message
      character(len=:), allocatable :: message
      logical :: found
      integer :: status

      expected_message = make_expected_message(TYPESTRING, KEY, VALUESTRING)
      @assertFalse(is_blank(expected_message) > 0, ERROR_EXPECTED_MESSAGE_BLANK)
      call ESMF_HConfigAdd(hconfig, EXPECTED, addKeyString=KEY, rc=status)
      @assertEqual(0, status, ERROR_ADD_FAIL)
      call get_value(hconfig, actual, found, message, KEY, rc=status)
      @assertEqual(0, status, ERROR_GET_HCONFIG_FAILED)
      @assertTrue(found, ERROR_NOT_FOUND // KEY)
      @assertTrue(actual == EXPECTED, make_mismatch_error_message(actual, EXPECTED)) 
      @assertEqual(expected_message, message, ERROR_MESSAGE_MISMATCH)

   end subroutine test_get_string

   @Before
   subroutine set_up()
      
      integer :: status

      if(.not. hconfig_is_created) then
         hconfig = ESMF_HConfigCreate(rc=status)
         hconfig_is_created = (status == 0)
      end if
      @assertTrue(hconfig_is_created, 'HConfig was not created.')

   end subroutine set_up

   @After
   subroutine tear_down()

      integer :: status

      if(hconfig_is_created) call ESMF_HConfigDestroy(hconfig, rc=status)
      hconfig_is_created = .FALSE.
      @assertFalse(hconfig_is_created, 'HConfig was not destroyed.')

   end subroutine tear_down

   function make_expected_message(typestring, keystring, valuestring, rankstring)&
         result(expected_message)
      character(len=:), allocatable :: expected_message
      character(len=*), intent(in) :: typestring, keystring, valuestring
      character(len=*), optional, intent(in) :: rankstring
      character(len=*), parameter :: J_ = ', '

      if(present(rankstring)) then
         expected_message = typestring //J_// keystring //J_// valuestring //J_// rankstring
      else
         expected_message = typestring //J_// keystring //J_// valuestring
      end if

   end function make_expected_message

   function make_mismatch_error_message(actual, expected, prolog, bridge, epilog) result(error_message)
      character(len=:), allocatable :: error_message
      class(*), intent(in) :: actual, expected
      character(len=*), optional, intent(in) :: prolog, bridge, epilog
      character(len=:), allocatable :: actual_string, expected_string
      character(len=:), allocatable :: prolog_, epilog_, bridge_

      if(present(prolog)) then
         prolog_ = trim(adjustl(prolog)) // SPACE
      else
         prolog_ = ''
      end if

      if(present(epilog)) then
         epilog_ = SPACE // trim(adjustl(epilog))
      else
         epilog_ = ''
      end if

      if(present(bridge)) then
         bridge_ = SPACE // trim(adjustl(bridge)) // SPACE
      else
         bridge_ = ' does not match '
      end if

      if(same_type_as(actual, expected)) then
         actual_string = write_valuestring(actual)
         expected_string = write_valuestring(expected)
         error_message = prolog_ // actual_string // bridge_ // expected_string // epilog_
      else
         error_message = ''
      endif

   end function make_mismatch_error_message

   function write_valuestring(value) result(valuestring)
      character(len=:), allocatable :: valuestring
      class(*), intent(in) :: value
      character(len=MAXSTRLEN) :: rawstring
      integer :: ios

      select type(value)
      type is (integer(kind=ESMF_KIND_I4))
         write(rawstring, fmt='(I32)', iostat=ios) value
      type is (integer(kind=ESMF_KIND_I8))
         write(rawstring, fmt='(I32)', iostat=ios) value
      type is (real(kind=ESMF_KIND_R4))
         write(rawstring, fmt='(G32.16)', iostat=ios) value
      type is (real(kind=ESMF_KIND_R8))
         write(rawstring, fmt='(G32.16)', iostat=ios) value
      type is (logical)
         write(rawstring, fmt='(L1)', iostat=ios) value
      type is (character(len=*))
         rawstring = value
         ios = 0
      end select
      
      if(ios==0) then
         valuestring = trim(adjustl(rawstring))
      else
         valuestring = ''
      end if
      
   end function write_valuestring

   logical function is_blank(string)
      character(len=*), intent(in) :: string

      is_blank = (len_trim(string) == 0)

   end function is_blank

end module Test_hconfig_get
