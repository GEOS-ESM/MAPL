module Test_AddFieldSpec
   use funit
   use mapl3g_UngriddedDimsSpec, only: UngriddedDimsSpec
   use mapl3g_FieldSpec, only: FieldSpec
   use mapl3g_StateSpec, only: StateSpec
   use mapl3g_VerticalDimSpec
   use mapl3g_VirtualConnectionPt
   use mapl3g_ActualConnectionPt
   use mapl3g_StateItemSpec
   use mapl3g_VerticalGeom
   use gftl2_StringVector
   use ESMF
   implicit none

contains

   @test
   ! This first test really just exercises the interfaces. To compile
   ! is to pass.
   subroutine test_add_one_field()
      type(StateSpec) :: state_spec
      type(ESMF_Geom) :: geom
      type(VerticalGeom) :: vertical_geom
      type(VerticalDimSpec) :: vertical_dim_spec
      type(StringVector) :: attributes
      call state_spec%add_item('A', &
           FieldSpec(geom, vertical_geom, vertical_dim_spec, ESMF_TYPEKIND_R4, UngriddedDimsSpec(), &
           '', '', 'unknown', attributes))

   end subroutine test_add_one_field
   
   @test
   ! Just a sanity check that the underling gFTL is being
   ! correctly wrapped.   First we make sure that we get a failure
   ! when retrieving an item that does not exist, then we check
   ! that we succeed when getting an item that does.   (But we do
   ! not check the contents of that item.)

   subroutine test_get_item()
      use mapl3g_stateitemspecmap
      type(StateSpec) :: state_spec
      class(StateItemSpec), pointer :: item_spec

      type(FieldSpec) :: field_spec
      type(ESMF_Geom) :: geom
      type(VerticalGeom) :: vertical_geom
      type(VerticalDimSpec) :: vertical_dim_spec
      type(StringVector) :: attributes

      field_spec = FieldSpec(geom, vertical_geom, vertical_dim_spec, ESMF_TYPEKIND_R4, UngriddedDimsSpec(), &
           '', '', 'unknown', attributes)
      call state_spec%add_item('A', field_spec)

      ! Different name/key
      item_spec => state_spec%get_item('B')
      @assert_that(associated(item_spec), is(false()))

      ! Same name/key
      item_spec => state_spec%get_item('A')
      @assert_that(associated(item_spec), is(true()))

      
   end subroutine test_get_item

!   @test
   ! Test that we can add vertical coordinates to a field
   subroutine test_vertical()
      use mapl3g_MultiState
      type(FieldSpec) :: field_spec

      type(ESMF_Grid) :: grid
      type(ESMF_Geom) :: geom
      type(VerticalGeom) :: vertical_geom
      type(VerticalDimSpec) :: vertical_dim_spec
      type(ESMF_Info) :: info
      type(ESMF_State) :: state
      type(MultiState) :: multi_state
      type(ESMF_Field) :: f
      integer :: rank
      integer :: status
      type(StringVector) :: attributes

      grid = ESMF_GridCreateNoPeriDim(maxIndex=[4,4], name='I_AM_GROOT', rc=status)
      call ESMF_InfoGetFromHost(grid, info, rc=status)
      call ESMF_InfoSet(info, '/MAPL/GEOM/VERTICAL', 'CENTER', rc=status)
      geom = ESMF_GeomCreate(grid, ESMF_STAGGERLOC_INVALID)
      vertical_dim_spec = VERTICAL_DIM_CENTER
      field_spec = FieldSpec(geom, vertical_geom, vertical_dim_spec, ESMF_TYPEKIND_R4, UngriddedDimsSpec(), &
           '', '', '', attributes)
      call field_spec%create([ StateItemSpecPtr :: ], rc=status)
      call field_spec%allocate(rc=status)

      multi_state = MultiState(importState=ESMF_StateCreate(), exportState=ESMF_StateCreate())
      call field_spec%add_to_state(multi_state, ActualConnectionPt(VirtualConnectionPt(ESMF_STATEINTENT_EXPORT, 'T')), rc=status)

      call multi_state%get_state(state, ESMF_STATEINTENT_EXPORT, rc=status)
      call ESMF_StateGet(state, 'T', f, rc=status)

      call ESMF_FieldGet(f, rank=rank, rc=status)
      @assert_that(rank, is(3))
      
   end subroutine test_vertical

   @test
   ! Test that we can construct a "surface" ESMF Field on a grid that
   ! has vertical coords.
   subroutine test_vertical_surface()
      use mapl3g_MultiState
      type(FieldSpec) :: field_spec

      type(ESMF_Grid) :: grid
      type(ESMF_Field) :: field
      real(kind=ESMF_KIND_R8), pointer :: centerZ(:)
      real(kind=ESMF_KIND_R4), pointer :: x2d(:,:)
      real(kind=ESMF_KIND_R4), pointer :: x3d(:,:,:)
      integer :: k
      integer :: status

      grid = ESMF_GridCreateNoPeriDim( &
           countsPerDEDim1=[4], &
           countsPerDEDim2=[4], &
           countsPerDEDim3=[10], &
           name='I_AM_GROOT', &
           coordDep1=[1], & ! 1st coord is 1D and depends on 1st Grid dim
           coordDep2=[2], & ! 2nd coord is 1D and depends on 2nd Grid dim
           coordDep3=[3], & ! 3rd coord is 1D and depends on 3rd Grid dim
           rc=status)
      @assert_that(status, is(0))
      call ESMF_GridAddCoord(grid, staggerloc=ESMF_STAGGERLOC_CORNER_VCENTER, rc=status)
      @assert_that(status, is(0))
      call ESMF_GridGetCoord(grid, coordDim=3, &
          staggerloc=ESMF_STAGGERLOC_CORNER_VCENTER,         &
          farrayPtr=centerZ, rc=status)
      @assert_that(status, is(0))
      centerZ = [(k, k=1,10)]

      field = ESMF_FieldCreate(grid, ESMF_TYPEKIND_R4, gridToFieldMap=[1,2,0], rc=status)
      @assert_that(status, is(0))
      call ESMF_FieldGet(field, farrayptr=x2d, rc=status)
      @assert_that(status, is(0))
!!$      @assert_that(all(shape(x3d) == [4,4,10]), is(true()))
      @assert_that(all(shape(x2d) == [4,4]), is(true()))
      
!!$      field = ESMF_FieldEmptyCreate(rc=status)
!!$      @assert_that(status, is(0))
!!$      call ESMF_FieldEmptySet(field, grid, rc=status)
!!$      @assert_that(status, is(0))
!!$      call ESMF_FieldEmptyComplete(field, ESMF_TYPEKIND_R4, &
!!$           rc=status)
!!$      @assert_that(status, is(0))
      

   end subroutine test_vertical_surface

   end module Test_AddFieldSpec
