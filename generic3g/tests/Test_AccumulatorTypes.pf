#define _RETURN_(R, S) if(present(R)) R = S; return
#define _RETURN(S) _RETURN_(rc, S)
#define _SUCCESS 0
#include "MAPL_TestErr.h"
#include "unused_dummy.H"
module Test_AccumulatorTypes
!   use mapl3g_AccumulatorAction
   use mapl3g_MeanAccumulator
   use esmf
   use funit
   use MAPL_FieldUtils
   implicit none

   integer, parameter :: R4 = ESMF_KIND_R4
   integer, parameter :: R8 = ESMF_KIND_R8
   integer, parameter :: I8 = ESMF_KIND_I8
   integer(kind=ESMF_KIND_I4), parameter :: TIME_STEP = 1
   integer(kind=ESMF_KIND_I4), parameter :: START_TIME = 3000
   integer, parameter :: MAX_INDEX(2) = [4, 4]
   real(kind=ESMF_KIND_R8), parameter :: MIN_CORNER_COORD(2) = [0.0_R8, 0.0_R8]
   real(kind=ESMF_KIND_R8), parameter :: MAX_CORNER_COORD(2) = [4.0_R8, 4.0_R8]
   type(ESMF_TypeKind_Flag), parameter :: typekind = ESMF_TYPEKIND_R4

contains

   @Test
   subroutine test_calculate_mean_R4()
      type(MeanAccumulator) :: acc
      type(ESMF_State) :: importState, exportState
      type(ESMF_Clock) :: clock
      integer :: status
      integer(kind=ESMF_KIND_I8), parameter :: COUNTER = 4
      real(kind=ESMF_KIND_R4), parameter :: MEAN = 4.0_R4
      logical :: matches_expected
      real(kind=ESMF_KIND_R4), pointer :: fptr(:)
      integer :: n
      logical, allocatable :: mask(:)
      
      call initialize_objects(importState, exportState, clock, ESMF_TYPEKIND_R4, _RC)
      call acc%initialize(importState, exportState, clock, _RC)
      call FieldSet(acc%accumulation_field, COUNTER*MEAN, _RC)
      acc%counter_scalar = COUNTER
      acc%valid_mean = .TRUE.

      ! FIELD NOT UNDEF, ALL VALID_MEAN
      call acc%calculate_mean_R4(_RC)
      matches_expected = FieldIsConstant(acc%accumulation_field, MEAN, _RC)
      @assert_that(matches_expected, is(true()))

      ! FIELD(n) UNDEF, ALL_VALID_MEAN
      acc%valid_mean = .TRUE.
      call FieldSet(acc%accumulation_field, COUNTER*MEAN, _RC)
      call assign_fptr(acc%accumulation_field, fptr, _RC)
      n = size(fptr)-1
      call set_undef(fptr(n))
      allocate(mask(size(fptr)))
      mask = .TRUE.
      mask(n) = .FALSE.
      call acc%calculate_mean_R4(_RC)
      @assert_that(all(pack(fptr, mask) == MEAN), is(true()))
      @assertTrue(undef(fptr(n)))
      
      ! FIELD NOT UNDEF, VALID_MEAN(n) .FALSE.
      acc%valid_mean = .TRUE.
      call FieldSet(acc%accumulation_field, COUNTER*MEAN, _RC)
      acc%valid_mean(n) = .FALSE.
      call acc%calculate_mean_R4(_RC)
      @assert_that(all(pack(fptr, acc%valid_mean) == MEAN), is(true()))
      @assertTrue(undef(fptr(n)))
      
      ! FIELD(n) UNDEF, VALID_MEAN(n) .FALSE.
      acc%valid_mean = .TRUE.
      call FieldSet(acc%accumulation_field, COUNTER*MEAN, _RC)
      acc%valid_mean(n) = .FALSE.
      call assign_fptr(acc%accumulation_field, fptr, _RC)
      !@assert_that(n <= size(fptr), is(true()))
      call set_undef(fptr(n))
      mask = (.not. undef(fptr)) .and. acc%valid_mean
      call acc%calculate_mean_R4(_RC)
      @assert_that(all(pack(fptr, mask) == MEAN), is(true()))
      @assertTrue(undef(fptr(n)))

   end subroutine test_calculate_mean_R4

   @Test
   subroutine test_calculate_mean()
      type(MeanAccumulator) :: acc
      type(ESMF_State) :: importState, exportState
      type(ESMF_Clock) :: clock
      integer :: status
      integer(kind=ESMF_KIND_I8), parameter :: COUNTER = 4
      real(kind=ESMF_KIND_R4), parameter :: MEAN = 4.0_R4
      logical :: matches_expected
      type(ESMF_TypeKind_Flag), parameter :: TK = ESMF_TYPEKIND_R4
      
      call initialize_objects(importState, exportState, clock, TK, _RC)
      call acc%initialize(importState, exportState, clock, _RC)
      call FieldSet(acc%accumulation_field, COUNTER*MEAN, _RC)
      acc%counter_scalar = 0_I8
      acc%valid_mean = .TRUE.

      call acc%calculate_mean()
      @assertExceptionRaised()

      acc%counter_scalar = COUNTER
      call acc%calculate_mean()
      matches_expected = FieldIsConstant(acc%accumulation_field, MEAN, _RC)
      @assert_that(matches_expected, is(true()))

   end subroutine test_calculate_mean

   @Test
   subroutine test_clear_accumulator()
      type(MeanAccumulator) :: acc
      type(ESMF_State) :: importState, exportState
      type(ESMF_Clock) :: clock
      integer :: status

      call initialize_objects(importState, exportState, clock, ESMF_TYPEKIND_R4, _RC)
      call acc%initialize(importState, exportState, clock, _RC)
      acc%counter_scalar = 4
      call acc%clear_accumulator(_RC)
      @assertEqual(acc%counter_scalar, 0_I8)

   end subroutine test_clear_accumulator

   @Test
   subroutine test_clear_valid_mean()
      type(MeanAccumulator) :: acc
      type(ESMF_State) :: importState, exportState
      type(ESMF_Clock) :: clock
      integer :: status

      call initialize_objects(importState, exportState, clock, ESMF_TYPEKIND_R4, _RC)
      call acc%initialize(importState, exportState, clock, _RC)
      acc%valid_mean = .TRUE.
      call acc%clear_valid_mean(_RC)
      @assert_that(.not. any(acc%valid_mean), is(true()))

   end subroutine test_clear_valid_mean

   @Test
   subroutine test_invalidate()
      type(MeanAccumulator) :: acc
      type(ESMF_State) :: importState, exportState
      type(ESMF_Clock) :: clock
      integer :: status
      integer(kind=ESMF_KIND_I8), parameter :: N = 4_I8
      integer :: i
      type(ESMF_Field) :: importField

      call initialize_objects(importState, exportState, clock, ESMF_TYPEKIND_R4, _RC)
      call get_field(importState, importField, _RC)
      call FieldSet(importField, 1.0_R4, _RC)
      call acc%initialize(importState, exportState, clock, _RC)
      @assertEqual(acc%counter_scalar, 0_I8)
      do i=1, N
         call acc%invalidate(importState, exportState, clock, _RC)
      end do
      @assertEqual(acc%counter_scalar, N)

   end subroutine test_invalidate

   subroutine test_accumulate_mean_R4()
      class(MeanAccumulator) :: acc
      type(ESMF_State) :: importState, exportState
      type(ESMF_Clock) :: clock
      integer :: status
      type(ESMF_Field) :: update_field
      type(ESMF_TypeKind_Flag), parameter :: tk =ESMF_TYPEKIND_R4
      type(ESMF_Grid) :: grid
      real(kind=ESMF_KIND_R4), pointer :: upPtr(:), accPtr
      real(kind=ESMF_KIND_R4), parameter :: IMPORT_VALUE = 2.0_R4
      real(kind=ESMF_KIND_R4), parameter :: UPDATE_VALUE = 3.0_R4
      integer :: n

      call initialize_objects(importState, exportState, clock, tk, _RC)
      call get_field(importState, importField, _RC)
      call FieldSet(importField, IMPORT_VALUE, _RC)
      call acc%initialize(importState, exportState, clock, _RC)
      call initialize_field(update_field, typekind=tk, grid=grid, _RC)
      call assign_upPtr(update_field, upPtr, _RC)
      upPtr = UPDATE_VALUE

      call acc%accumulate_mean_R4(update_field, _RC)
      call assign_fptr(acc%accumulation_field, accPtr, _RC)
      @assertTrue(all(accPtr == IMPORT_VALUE+UPDATE_VALUE))


   end subroutine test_accumulate_mean_R4
   !todo test_accumulate_mean_R4
   !test cases(2): both defined, check accumulation_field & valid_mean
   !latest is undef, check accumulation_field
! HELPER PROCEDURES

   logical function is_initialized(rc) result(lval)
      integer, optional, intent(out) :: rc
      integer :: status

      lval = ESMF_IsInitialized(_RC)
      _RETURN(_SUCCESS)

   end function is_initialized

   elemental logical function undef(t) result(lval)
      use MAPL_InternalConstantsMod, only: MAPL_UNDEFINED_REAL
      real(kind=ESMF_KIND_R4), intent(in) :: t

      lval = t == MAPL_UNDEFINED_REAL

   end function undef

   subroutine set_undef(t)
      use MAPL_InternalConstantsMod, only: MAPL_UNDEFINED_REAL
      real(kind=ESMF_KIND_R4), intent(inout) :: t

      t = MAPL_UNDEFINED_REAL

   end subroutine set_undef

   subroutine initialize_field(field, typekind, grid, rc)
      type(ESMF_Field), intent(inout) :: field
      type(ESMF_TypeKind_Flag), intent(in) :: typekind
      type(ESMF_Grid), optional, intent(inout) :: grid
      integer, optional, intent(out) :: rc
      type(ESMF_Grid) :: grid_
      logical :: grid_created

      integer :: status
      
      grid_created = .FALSE.
      if(present(grid)) then
         grid_created = ESMF_GridIsCreated(grid, _RC)
         if(grid_created) grid_ = grid
      end if

      if(.not. grid_created) then
         grid_ = ESMF_GridCreateNoPeriDimUfrm(maxIndex=MAX_INDEX, &
            & minCornerCoord=MIN_CORNER_COORD, maxCornerCoord=MAX_CORNER_COORD, _RC)
      end if

      field = ESMF_FieldCreate(grid=grid_, typekind=typekind, _RC)
      
      if(present(grid)) grid = grid_
      _RETURN(_SUCCESS)

   end subroutine initialize_field

   subroutine initialize_objects(importState, exportState, clock, typekind, rc) 
      type(ESMF_State), intent(inout) :: importState, exportState
      type(ESMF_Clock), intent(inout) :: clock
      type(ESMF_TypeKind_Flag), intent(in) :: typekind
      integer, optional, intent(out) :: rc

      integer :: status
      type(ESMF_Field) :: importField, exportField
      type(ESMF_Time) :: startTime
      type(ESMF_TimeInterval) :: timeStep
      type(ESMF_Grid) :: grid

      call ESMF_TimeIntervalSet(timeStep, s=TIME_STEP, _RC)
      call ESMF_TimeSet(startTime, yy=START_TIME, _RC)
      clock = ESMF_ClockCreate(timeStep=timeStep, startTime=startTime, _RC)
      grid = ESMF_GridCreateNoPeriDimUfrm(maxIndex=MAX_INDEX, minCornerCoord=MIN_CORNER_COORD, maxCornerCoord=MAX_CORNER_COORD, _RC)
      importField = ESMF_FieldCreate(grid=grid, typekind=typekind, _RC)
      exportField = ESMF_FieldCreate(grid=grid, typekind=typekind, _RC)
      importState = ESMF_StateCreate(stateIntent=ESMF_STATEINTENT_IMPORT, fieldList=[importField], name='import', _RC)
      exportState = ESMF_StateCreate(stateIntent=ESMF_STATEINTENT_EXPORT, fieldList=[exportField], name='export', _RC)
      _RETURN(_SUCCESS)

   end subroutine initialize_objects

   subroutine get_field(state, field, rc)
      type(ESMF_State), intent(inout) :: state
      type(ESMF_Field), intent(inout) :: field
      integer, optional, intent(out) :: rc

      integer :: status
      character(len=ESMF_MAXSTR) :: itemNameList(1)

      call ESMF_StateGet(state, itemNameList=itemNameList, _RC)
      call ESMF_StateGet(state, itemName=itemNameList(1), field=field, _RC)
      _RETURN(_SUCCESS)

   end subroutine get_field
   
   subroutine destroy_objects(importState, exportState, clock, rc)
      type(ESMF_State), intent(inout) :: importState, exportState
      type(ESMF_Clock), intent(inout) :: clock
      integer, optional, intent(out) :: rc

      integer :: status
      type(ESMF_Field) :: importField, exportField
      type(ESMF_Grid) :: grid

      call get_field(importState, importField, _RC)
      call get_field(exportState, exportField, _RC)
      call ESMF_StateDestroy(importState, _RC)
      call ESMF_StateDestroy(exportState, _RC)
      call ESMF_FieldGet(importField, grid=grid, _RC)
      call ESMF_FieldDestroy(importField, _RC)
      call ESMF_FieldDestroy(exportField, _RC)
      call ESMF_GridDestroy(grid, _RC)
      call ESMF_ClockDestroy(clock, _RC)
      _RETURN(_SUCCESS)

   end subroutine destroy_objects

   @Before
   subroutine set_up()
      integer :: status

      if(is_initialized()) return
      call ESMF_Initialize(_RC)

   end subroutine set_up

end module Test_AccumulatorTypes
