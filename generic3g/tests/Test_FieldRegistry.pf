module Test_FieldRegistry
   use funit
   use MockItemSpecMod
   use mapl3g_FieldRegistry
   use mapl3g_AbstractStateItemSpec
   use mapl3g_ConnectionPoint
   use mapl3g_ConnectionSpec
   use mapl3g_AbstractActionSpec
   implicit none

contains

   ! Helpful function to check expected state of registry.
   logical function check(r, conn_pt, expected)
      type(FieldRegistry), intent(in) :: r 
      type(ConnectionPoint), intent(in) :: conn_pt
      character(*), intent(in) :: expected

      class(AbstractStateItemSpec), pointer :: spec
      check = .false.
      spec => r%get_item_spec(conn_pt)
      @assert_that(associated(spec), is(true()))

      select type(spec)
      type is (MockItemSpec)
         @assertEqual(expected, spec%name)
         check = .true.
      class default
         @assert_that(1,is(2))
      end select
   end function check


   @test
   ! Just a warmup
   subroutine test_get_item_spec_not_found()

      type(FieldRegistry) :: r
      class(AbstractStateItemSpec), pointer :: spec

      spec => r%get_item_spec(ConnectionPoint('my_gc', 'import', 'a'))
      @assert_that(associated(spec), is(false()))
      
   end subroutine test_get_item_spec_not_found
   
   @test
   subroutine test_add_item_duplicate()
      type(FieldRegistry) :: r
      integer :: status
      type(ConnectionPoint) :: cp
      cp = ConnectionPoint('A','A','A')
        call r%add_item_spec(cp, MockItemSpec('A'), rc=status)
        @assert_that(status, is(0))
        call r%add_item_spec(cp, MockItemSpec('A'), rc=status)
        @assertExceptionRaised('Duplicate registry entry.')
        @assert_that(status, is(not(0)))

   end subroutine test_add_item_duplicate
   

   @test
   subroutine test_get_item_spec_found()

      type(FieldRegistry) :: r
      class(AbstractStateItemSpec), pointer :: spec
      type(ConnectionPoint) :: cp_1

      cp_1 = ConnectionPoint('my_gc', 'import', 'a')
      call r%add_item_spec(cp_1, MockItemSpec('A'))

      spec => r%get_item_spec(cp_1)
      @assert_that(associated(spec), is(true()))
      if (.not. check(r, cp_1, 'A')) return

   end subroutine test_get_item_spec_found

   @test
   subroutine test_get_item_spec_multi()
      type(FieldRegistry) :: r 
      type(ConnectionPoint) :: cp_1, cp_2, cp_3
      integer :: status

      cp_1 = ConnectionPoint('grandchild_A', 'export', 'ae1')
      cp_2 = ConnectionPoint('child_A', 'export', 'ae2')
      cp_3 = ConnectionPoint('child_B', 'import', 'ai')

      call r%add_item_spec(cp_1, MockItemSpec('AE1'))
      call r%add_item_spec(cp_2, MockItemSpec('AE2'))
      call r%add_item_spec(cp_3, MockItemSpec('AI'))

      if (.not. check(r, cp_1, 'AE1')) return
      if (.not. check(r, cp_2, 'AE2')) return
      if (.not. check(r, cp_3, 'AI'))return

   end subroutine test_get_item_spec_multi


   @test
   subroutine test_connect()
      type(FieldRegistry) :: r
      class(AbstractStateItemSpec), pointer :: spec
      type(ConnectionPoint) :: cp_1, cp_2

      integer :: status

      cp_1 = ConnectionPoint('child_A', 'export', 'ae')
      cp_2 = ConnectionPoint('child_B', 'import', 'ai')

      call r%add_item_spec(cp_1, MockItemSpec('AE'))
      call r%add_item_spec(cp_2, MockItemSpec('AI'))

      call r%add_connection(ConnectionSpec(cp_1, cp_2), rc=status)
      @assert_that(status, is(0))

      spec => r%get_item_spec(cp_2)
      if (.not. check(r, cp_2, 'AE')) return

   end subroutine test_connect

   @test
   subroutine test_connect_chain()
      type(FieldRegistry) :: r
      class(AbstractStateItemSpec), pointer :: spec
      type(ConnectionPoint) :: cp_1, cp_2, cp_3

      integer :: status

      cp_1 = ConnectionPoint('grandchild_A', 'export', 'ae1')
      cp_2 = ConnectionPoint('child_A', 'export', 'ae2')
      cp_3 = ConnectionPoint('child_B', 'import', 'ai')

      call r%add_item_spec(cp_1, MockItemSpec('AE1'))
      call r%add_item_spec(cp_2, MockItemSpec('AE2'))
      call r%add_item_spec(cp_3, MockItemSpec('AI'))

      ! E-to-E
      call r%add_connection(ConnectionSpec(cp_1, cp_2), rc=status)
      @assert_that(status, is(0))
      ! sibling
      call r%add_connection(ConnectionSpec(cp_2, cp_3), rc=status)
      @assert_that(status, is(0))

      spec => r%get_item_spec(cp_3)
      if (.not. check(r, cp_3, 'AE1')) return

   end subroutine test_connect_chain

   !@test
   subroutine test_add_connection_invalid()
      type(FieldRegistry) :: r
      class(AbstractStateItemSpec), pointer :: spec
      integer :: status

      associate ( &
           cp_1 => ConnectionPoint('A', 'export', 'A'), &
           cp_2 => ConnectionPoint('B', 'import', 'A'))

        call r%add_item_spec(cp_1, MockItemSpec('AE1'),rc=status)
        call r%add_item_spec(cp_2, MockItemSpec('AE1'),rc=status)
        call r%add_connection(ConnectionSpec(cp_1, cp_2), rc=status)
        @assert_that(status, is(not(0)))
      end associate
        
   end subroutine test_add_connection_invalid


   @test
   ! Verify that sibling connections set active status, but not others.
   subroutine test_sibling_activation()
      type(FieldRegistry) :: r
      class(AbstractStateItemSpec), pointer :: spec

      type(ConnectionPoint) :: cp_1, cp_2, cp_3, cp_4
      type(ConnectionSpec) :: e2e, i2i, sib
           cp_1 = ConnectionPoint('A', 'export', 'A1')
           cp_2 = ConnectionPoint('P', 'export', 'A2')
           cp_3 = ConnectionPoint('B', 'import', 'A3')
           cp_4 = ConnectionPoint('C', 'import', 'A4')

        call r%add_item_spec(cp_1, MockItemSpec('A1'))
        call r%add_item_spec(cp_2, MockItemSpec('A2'))
        call r%add_item_spec(cp_3, MockItemSpec('A3'))
        call r%add_item_spec(cp_4, MockItemSpec('A4'))

        !-------------------------------------------
        !
        !                    sib*
        !             cp_2   --->    cp_3
        !              ^              |
        !     e2e      |              |     i2i
        !              |              V
        !             cp_1           cp_4
        !
        !-------------------------------------------
             e2e = ConnectionSpec(cp_1, cp_2)
             i2i = ConnectionSpec(cp_3, cp_4)
             sib = ConnectionSpec(cp_2, cp_3)

          spec => r%get_item_spec(cp_1) ! ultimate export
          @assert_that(spec%is_active(), is(false()))

          call r%add_connection(e2e)
          @assert_that(spec%is_active(), is(false()))
          if (.not. check(r, cp_2, 'A1')) return


          ! 1 => A, 2 => A, 3 => C, 4 => D


          call r%add_connection(i2i)
          @assert_that(spec%is_active(), is(false()))
          if (.not. check(r, cp_4, 'A3')) return

          ! 1 => A, 2 => A, 3 => C, 4 => C

          call r%add_connection(sib)

          ! C = A
          ! 1 => A, 2 => A, 3 => C, 4 => C

          spec => r%get_item_spec(cp_1)! ultimate export
          @assert_that('cp_1', spec%is_active(), is(true()))

          spec => r%get_item_spec(cp_2)
          @assert_that(spec%is_active(), is(true()))

          spec => r%get_item_spec(cp_3) 
          @assert_that(spec%is_active(), is(true()))

          spec => r%get_item_spec(cp_4)
          @assert_that('cp_4', spec%is_active(), is(true()))

   end subroutine test_sibling_activation
          
          
       
   @test
   ! Internal state items are always active
   subroutine test_internal_activation()
      type(FieldRegistry) :: r
      class(AbstractStateItemSpec), pointer :: spec

      type(ConnectionPoint) :: cp_1, cp_2, cp_3
           cp_1 = ConnectionPoint('A', 'internal', 'A')
           cp_2 = ConnectionPoint('A', 'export', 'A')
           cp_3 = ConnectionPoint('A', 'import', 'A')

        call r%add_item_spec(cp_1, MockItemSpec('A1'))
        call r%add_item_spec(cp_2, MockItemSpec('A2'))
        call r%add_item_spec(cp_3, MockItemSpec('A3'))

        spec => r%get_item_spec(cp_1)
        @assert_that(spec%is_active(), is(true()))
        
        spec => r%get_item_spec(cp_2)
        @assert_that(spec%is_active(), is(false()))
        
        spec => r%get_item_spec(cp_3)
        @assert_that(spec%is_active(), is(false()))
        
   end subroutine test_internal_activation
          
   @test
   ! Terminate import must also set a spec to 'active'.
   subroutine test_terminate_import()
      type(FieldRegistry) :: r
      class(AbstractStateItemSpec), pointer :: spec

      type (ConnectionPoint) :: cp_3
      cp_3 = ConnectionPoint('A', 'import', 'A')

        call r%add_item_spec(cp_3, MockItemSpec('A3'))
        call r%terminate_import(cp_3)
        
        spec => r%get_item_spec(cp_3)
        @assert_that(spec%is_active(), is(true()))
      
   end subroutine test_terminate_import
          
   @test
   ! Verify that errors are properly trapped
   subroutine test_terminate_import_not_import()
      type(FieldRegistry) :: r
      class(AbstractStateItemSpec), pointer :: spec
      type(ConnectionPoint) :: cp_3
      integer :: status

      cp_3 = ConnectionPoint('A', 'export', 'A')

        call r%add_item_spec(cp_3, MockItemSpec('A3'))
        call r%terminate_import(cp_3, rc=status)
        @assertExceptionRaised('Cannot terminate import on item that is not an import.')
        @assert_that(status, is(not(0)))
        
      
   end subroutine test_terminate_import_not_import

   @test
   ! Verify that errors are properly trapped
   subroutine test_terminate_import_does_not_exist()
      type(FieldRegistry) :: r
      integer :: status

      type(ConnectionPoint) :: cp_3
      cp_3 = ConnectionPoint('A', 'import', 'A')

      call r%terminate_import(cp_3, rc=status)
      @assertExceptionRaised('Cannot terminate import on unregistered item.')
      @assert_that(status, is(not(0)))
        
   end subroutine test_terminate_import_does_not_exist


   @test
   ! Verify that an extension is created when an export is
   ! semi-compatible with an import.
   subroutine test_create_extension()
      type(FieldRegistry) :: r
      class(AbstractStateItemSpec), pointer :: dst_spec, src_spec
      class(AbstractActionSpec), allocatable :: action_spec
      integer :: status

      type(ConnectionPoint) :: e1, i1
      e1 = ConnectionPoint('A', 'export', 'Q')
      i1 = ConnectionPoint('B', 'import', 'Q')
        call r%add_item_spec(e1, MockItemSpec('E1','fruit'))
        call r%add_item_spec(i1, MockItemSpec('I1','animal'))
        src_spec => r%get_item_spec(e1)
        dst_spec => r%get_item_spec(i1)

        @assert_that((dst_spec%can_connect_to(src_spec)), is(true()))
        @assert_that((dst_spec%requires_extension(src_spec)), is(true()))

        action_spec = src_spec%make_extension(dst_spec)
        select type (action_spec)
        type is (MockActionSpec)
           @assertEqual('fruit ==> animal', action_spec%details)
        class default
           @assert_that(1, is(2))
        end select
      
   end subroutine test_create_extension


   
end module Test_FieldRegistry
