module Test_HierarchicalRegistry
   use funit
   use mapl3g_AbstractRegistry
   use mapl3g_HierarchicalRegistry
   use mapl3g_AbstractStateItemSpec
   use mapl3g_ConnectionPt
   use mapl3g_ActualPtVector
   use mapl3g_VirtualConnectionPt
   use mapl3g_ActualConnectionPt
   use mapl3g_ConnectionSpec
   use mapl3g_AbstractActionSpec
   use MockItemSpecMod
   implicit none

   interface check
      module procedure check_actual
      module procedure check_virtual
   end interface check


#define CP(x,y)  ConnectionPt(x,y)
contains

   ! Helpful function to check expected state of registry.  Inputs are
   ! a registry, an actual point, and expected name of mock object.
   logical function check_actual(r, actual_pt, expected_name) result(check)
      type(HierarchicalRegistry), intent(in) :: r 
      type(ActualConnectionPt), intent(in) :: actual_pt
      character(*), intent(in) :: expected_name

      class(AbstractStateItemSpec), pointer :: spec
      check = .false.
      spec => r%get_item_spec(actual_pt)
      @assert_that(associated(spec), is(true()))

      select type(spec)
      type is (MockItemSpec)
         @assertEqual(expected_name, spec%name)
         check = .true.
      class default
         @assert_that(1,is(2))
      end select
   end function check_actual

   ! Helpful function to check expected state of registry.  Inputs are
   ! a registry, a virtual point, and expected name of mock object.
   logical function check_virtual(r, virtual_pt, expected_names) result(check)
      type(HierarchicalRegistry), intent(in) :: r 
      type(VirtualConnectionPt), intent(in) :: virtual_pt
      character(*), intent(in) :: expected_names(:)

      type(ActualPtVector), pointer :: actual_pts
      type(ActualConnectionPt), pointer :: actual_pt
      integer :: i
      
      check = .false.
      actual_pts => r%get_actual_pts(virtual_pt)
      @assert_that(associated(actual_pts), is(true()))

      do i = 1, actual_pts%size()
         actual_pt => actual_pts%of(i)
         check = check_actual(r, actual_pt, expected_names(i))
      end do
   end function check_virtual


   @test
   subroutine test_make_extension_pt_import()
      type(HierarchicalRegistry) :: r
      type(ActualConnectionPt) ::  a_pt, e_pt

      a_pt = ActualConnectionPt('import', 'T')
      e_pt = r%make_extension_pt(a_pt, 'child')
      @assert_that(e_pt == ActualConnectionPt('import/<extensions>/<child>/T'), is(true()))

      a_pt = e_pt
      e_pt = r%make_extension_pt(a_pt, 'child')
      @assert_that(e_pt == ActualConnectionPt('import/<extensions>/<child>/T'), is(true()))
     

   end subroutine test_make_extension_pt_import

   @test
   subroutine test_get_item_spec_not_found()

      type(HierarchicalRegistry) :: r
      class(AbstractStateItemSpec), pointer :: spec

      r = HierarchicalRegistry('A')
      spec => r%get_item_spec(ActualConnectionPt('import', 'a'))
      @assertExceptionRaised('status=1')
      @assert_that(associated(spec), is(false()))
      
   end subroutine test_get_item_spec_not_found
   
   @test
   subroutine test_add_item_duplicate_fail()
      type(HierarchicalRegistry) :: r
      integer :: status
      type(ActualConnectionPt) :: cp

      r = HierarchicalRegistry('A')

      cp = ActualConnectionPt('A','A')
      call r%add_item_spec(cp, MockItemSpec('A'), rc=status)
      @assert_that(status, is(0))
      call r%add_item_spec(cp, MockItemSpec('A'), rc=status)
      @assertExceptionRaised('Duplicate item name.')
      @assert_that(status, is(not(0)))

   end subroutine test_add_item_duplicate_fail
   

   @test
   subroutine test_get_item_spec_found()
      type(HierarchicalRegistry) :: r
      class(AbstractStateItemSpec), pointer :: spec
      type(ActualConnectionPt) :: cp

      r = HierarchicalRegistry('A')
      cp = ActualConnectionPt('import', 'a')
      call r%add_item_spec(cp, MockItemSpec('A'))

      spec => r%get_item_spec(cp)
      @assert_that(associated(spec), is(true()))
      if (.not. check(r, cp, 'A')) return

   end subroutine test_get_item_spec_found



   @test
   ! Add multiple specs and check that the correct spec is returned by
   ! name.
   subroutine test_get_item_spec_multi()
      type(HierarchicalRegistry) :: r 
      type(ActualConnectionPt) :: cp_1, cp_2, cp_3

      cp_1 = ActualConnectionPt('export', 'ae1')
      cp_2 = ActualConnectionPt('export', 'ae2')
      cp_3 = ActualConnectionPt('import', 'ai')

      r = HierarchicalRegistry('A')
      call r%add_item_spec(cp_1, MockItemSpec('AE1'))
      call r%add_item_spec(cp_2, MockItemSpec('AE2'))
      call r%add_item_spec(cp_3, MockItemSpec('AI'))

      if (.not. check(r, cp_1, 'AE1')) return
      if (.not. check(r, cp_2, 'AE2')) return
      if (.not. check(r, cp_3, 'AI'))return

   end subroutine test_get_item_spec_multi

   @test
   subroutine test_get_subregistry()
      type(HierarchicalRegistry), target :: child_registry
      type(HierarchicalRegistry), target :: r
      class(AbstractRegistry), pointer :: ptr
      
      r = HierarchicalRegistry('parent')
      child_registry = HierarchicalRegistry('child')
      call r%add_subregistry(child_registry)

      ptr => r%get_subregistry('child')
      @assert_that(associated(ptr), is(true()))

   end subroutine test_get_subregistry


   @test
   subroutine test_get_subregistry_fail_not_found()
      type(HierarchicalRegistry), target :: child_registry
      type(HierarchicalRegistry), target :: r
      class(AbstractRegistry), pointer :: ptr

      integer :: status

      child_registry = HierarchicalRegistry('A')
      r = HierarchicalRegistry('parent')
      
      call r%add_subregistry(child_registry)
      ptr => r%get_subregistry('B', rc=status)
      @assertExceptionRaised('status=1')
      @assert_that(status, is(not(0)))
      @assert_that(associated(ptr), is(false()))
      
   end subroutine test_get_subregistry_fail_not_found


   @test
   ! Very simple sibling connection
   subroutine test_connect()
      type(HierarchicalRegistry) :: r
      type(HierarchicalRegistry), target :: r_A, r_B ! child registries
      type(VirtualConnectionPt) :: cp_A, cp_B
      type(ConnectionSpec) :: conn
      integer :: status

      r_a = HierarchicalRegistry('child_A')
      r_b = HierarchicalRegistry('child_B')

      call r%add_subregistry(r_a)
      call r%add_subregistry(r_b)

      cp_A = VirtualConnectionPt('export', 'ae')
      cp_B = VirtualConnectionPt('import', 'ai')

      call r_a%add_item_spec(cp_A, MockItemSpec('AE'))
      call r_b%add_item_spec(cp_B, MockItemSpec('AI'))

      r = HierarchicalRegistry('P')
      call r%add_subregistry(r_a)
      call r%add_subregistry(r_b)
      conn = ConnectionSpec(CP('child_A', cp_A), CP('child_B', cp_B))
      call r%add_connection(conn, rc=status)
      @assert_that(status, is(0))

      if (.not. check(r_b, cp_B, ['AE'])) return

   end subroutine test_connect

   @test
   subroutine test_e2e()
      type(HierarchicalRegistry) :: r
      type(HierarchicalRegistry), target :: r_A
      type(VirtualConnectionPt) :: cp_1, cp_2

      integer :: status

      r_A = HierarchicalRegistry('A')
      call r%add_subregistry(r_A)

      cp_1 = VirtualConnectionPt('export', 'ae1')
      cp_2 = VirtualConnectionPt('export', 'ae2')

      ! True export
      call r_A%add_item_spec(cp_1, MockItemSpec('AE1'))

      ! E-to-E with rename
      call r%add_connection(ConnectionSpec(CP('A',cp_1), CP(SELF,cp_2)), rc=status)
      @assert_that(status, is(0))

      if (.not. check(r, cp_2, ['AE1'])) return

   end subroutine test_e2e

   @test
   ! For E2E, we expect the parent actual_pt to be the one specified by the connection,
   ! rather than the one specified by the child.  This is in addition to the analogous
   ! assumption about the virtual pt, which is verified in the previous test.
   subroutine test_e2e_preserve_actual_pt()
      type(HierarchicalRegistry) :: r
      type(HierarchicalRegistry), target :: r_A
      type(VirtualConnectionPt) :: cp_1, cp_2

      integer :: status

      r_A = HierarchicalRegistry('A')
      call r%add_subregistry(r_A)

      cp_1 = VirtualConnectionPt('export', 'ae1')
      cp_2 = VirtualConnectionPt('export', 'ae2')

      ! True export
      call r_A%add_item_spec(cp_1, MockItemSpec('AE1'))

      ! E-to-E with rename
      call r%add_connection(ConnectionSpec(CP('A',cp_1), CP(SELF,cp_2)), rc=status)

      @assert_that(r%has_item_spec(ActualConnectionPt(cp_2)), is(true()))

   end subroutine test_e2e_preserve_actual_pt

   
   @test
   ! This procedure testss an "E-to-E" style connection that
   ! propagates an export from a child to a parent.  (Grandchild to
   ! component "A" in this case.)
   ! A sibling connection is then made at the grandparent level and we check
   ! that the original export is indeed activated.
   subroutine test_connect_chain()
      type(HierarchicalRegistry) :: r
      type(HierarchicalRegistry), target :: r_A, r_B, r_grandchild
      type(VirtualConnectionPt) :: cp_1, cp_2, cp_3

      integer :: status

      r_grandchild = HierarchicalRegistry('grandchild')
      r_A = HierarchicalRegistry('A')
      r_B = HierarchicalRegistry('B')
      
      call r_A%add_subregistry(r_grandchild)
      call r%add_subregistry(r_A)
      call r%add_subregistry(r_B)

      cp_1 = VirtualConnectionPt('export', 'ae1')
      cp_2 = VirtualConnectionPt('export', 'ae2')
      cp_3 = VirtualConnectionPt('import', 'ai')

      call r_grandchild%add_item_spec(cp_1, MockItemSpec('AE1'))
      call r_B%add_item_spec(cp_3, MockItemSpec('AI'))

      ! E-to-E
      call r_A%add_connection(ConnectionSpec(CP('grandchild',cp_1), CP(SELF,cp_2)), rc=status)
      @assert_that(status, is(0))
      ! sibling
      call r%add_connection(ConnectionSpec(CP('A',cp_2), CP('B', cp_3)), rc=status)
      @assert_that(status, is(0))

      if (.not. check(r_B, cp_3, ['AE1'])) return

   end subroutine test_connect_chain


   @test
   ! Verify that sibling connections set active status, but not others.
   subroutine test_sibling_activation()
      type(HierarchicalRegistry) :: r
      type(HierarchicalRegistry), target :: r_A, r_B, r_P, r_C
      class(AbstractStateItemSpec), pointer :: spec

      type(VirtualConnectionPt) :: cp_1, cp_2, cp_3, cp_4
      type(ConnectionSpec) :: e2e, i2i, sib

      r_P = HierarchicalRegistry('P')
      r_A = HierarchicalRegistry('A')
      r_B = HierarchicalRegistry('B')
      r_C = HierarchicalRegistry('C')

      call r%add_subregistry(r_P)
      call r%add_subregistry(r_B)

      call r_P%add_subregistry(r_A)
      call r_B%add_subregistry(r_C)

      cp_1 = VirtualConnectionPt('export', 'A1')
      cp_2 = VirtualConnectionPt('export', 'A2')
      cp_3 = VirtualConnectionPt('import', 'A3')
      cp_4 = VirtualConnectionPt('import', 'A4')

      call r_A%add_item_spec(cp_1, MockItemSpec('A1'))
      call r_C%add_item_spec(cp_4, MockItemSpec('A4'))

        !-------------------------------------------
        !
        !                    sib*
        !          P  cp_2   --->    cp_3  B
        !              ^              |
        !     e2e      |              |     i2i
        !              |              V
        !          A  cp_1           cp_4  C
        !
        !-------------------------------------------
      e2e = ConnectionSpec(CP('A',cp_1), CP(SELF,cp_2))
      i2i = ConnectionSpec(CP('C',cp_4), CP(SELF,cp_3))
      sib = ConnectionSpec(CP('P',cp_2), CP('B', cp_3))

      spec => r_A%get_item_spec(ActualConnectionPt(cp_1)) ! ultimate export
      @assert_that(spec%is_active(), is(false()))

      call r_P%add_connection(e2e)
      @assert_that(spec%is_active(), is(false()))
      if (.not. check(r_P, cp_2, ['A1'])) return
      ! 1 => A, 2 => A, 3 => C, 4 => D

      call r_B%add_connection(i2i)
      @assert_that(spec%is_active(), is(false()))
      if (.not. check(r_B, cp_3, ['A4'])) return
      ! 1 => A, 2 => A, 3 => C, 4 => C

      call r%add_connection(sib)

      ! C = A
      ! 1 => A, 2 => A, 3 => C, 4 => C
      
      spec => r_A%get_item_spec(ActualConnectionPt(cp_1))
      @assert_that('cp_1', spec%is_active(), is(true()))
      
      spec => r_P%get_item_spec(ActualConnectionPt(cp_2))
      @assert_that(spec%is_active(), is(true()))
      
      spec => r_B%get_item_spec(ActualConnectionPt(cp_3))
      @assert_that(spec%is_active(), is(true()))
      
      spec => r_C%get_item_spec(ActualConnectionPt(cp_4))
      @assert_that('cp_4', spec%is_active(), is(true()))
      
   end subroutine test_sibling_activation
          
       
   @test
   ! Internal state items are always active
   subroutine test_internal_activation()
      type(HierarchicalRegistry) :: r
      class(AbstractStateItemSpec), pointer :: spec

      type(ActualConnectionPt) :: cp_1, cp_2, cp_3
           cp_1 = ActualConnectionPt('internal', 'A')
           cp_2 = ActualConnectionPt('export', 'A')
           cp_3 = ActualConnectionPt('import', 'A')

        call r%add_item_spec(cp_1, MockItemSpec('A1'))
        call r%add_item_spec(cp_2, MockItemSpec('A2'))
        call r%add_item_spec(cp_3, MockItemSpec('A3'))

        spec => r%get_item_spec(cp_1)
        @assert_that(spec%is_active(), is(true()))
        
        spec => r%get_item_spec(cp_2)
        @assert_that(spec%is_active(), is(false()))
        
        spec => r%get_item_spec(cp_3)
        @assert_that(spec%is_active(), is(false()))
        
   end subroutine test_internal_activation
          
   @test
   ! Verify that an extension is created when an export is
   ! semi-compatible with an import.
   subroutine test_create_extension()
      type(HierarchicalRegistry), target :: r_A, r_B
      class(AbstractStateItemSpec), pointer :: dst_spec, src_spec
      class(AbstractActionSpec), allocatable :: action_spec

      type(ActualConnectionPt) :: e1, i1

      e1 = ActualConnectionPt('export', 'Q')
      i1 = ActualConnectionPt('import', 'Q')
      call r_A%add_item_spec(e1, MockItemSpec('E1','fruit'))
      call r_B%add_item_spec(i1, MockItemSpec('I1','animal'))

      src_spec => r_A%get_item_spec(e1)
      dst_spec => r_B%get_item_spec(i1)

      @assert_that((dst_spec%can_connect_to(src_spec)), is(true()))
      @assert_that((dst_spec%requires_extension(src_spec)), is(true()))

      action_spec = src_spec%make_extension(dst_spec)
      select type (action_spec)
      type is (MockActionSpec)
         @assertEqual('fruit ==> animal', action_spec%details)
      class default
         @assert_that(1, is(2))
      end select
      
   end subroutine test_create_extension


        !-------------------------------------------
        !
        !              parent
        !                |
        !                |
        !                |
        !              child   (import, T)
        !
        !-------------------------------------------
   @test
   subroutine test_propagate_import()
      type(HierarchicalRegistry), target :: r_child, r_parent

      r_child = HierarchicalRegistry('child')
      call r_parent%add_subregistry(r_child)
      call r_child%add_item_spec(VirtualConnectionPt('import', 'T'), MockItemSpec('T_child'))
      call r_parent%propagate_unsatisfied_imports()

      @assert_that(r_parent%has_item_spec(VirtualConnectionPt('import', 'T')), is(true()))
      @assert_that(r_parent%has_item_spec(ActualConnectionPt('import/<extensions>/<child>/T')), is(true()))
      
   end subroutine test_propagate_import

   ! If a parent has two children that both need the same import (as
   ! determined by short name), then extensions must be used to
   ! represent both.

        !-------------------------------------------
        !
        !                  sib*
        !              A   --->     B
        !                          / \  
        !                         /   \      i2i
        !                        /     \
        !                       C       D
        !
        !-------------------------------------------

   ! We expect B to have a virtual pt with 2 actual pts from children.
   ! We also expect export from A to satisfy both imports.

   @test
   subroutine test_multi_import()
      type(HierarchicalRegistry), target :: r_C, r_D, r_A, r_B
      type(HierarchicalRegistry) :: r_P 
      type(VirtualConnectionPt) :: T_A, T_B, T_C, T_D
      type(ActualConnectionPt) :: extension_pt

      r_A = HierarchicalRegistry('A')
      r_B = HierarchicalRegistry('B')
      r_C = HierarchicalRegistry('C')
      r_D = HierarchicalRegistry('D')
      
      call r_B%add_subregistry(r_C)
      call r_B%add_subregistry(r_D)
      call r_P%add_subregistry(r_A)
      call r_P%add_subregistry(r_B)

      T_A = VirtualConnectionPt('export', 'T')
      T_B = VirtualConnectionPt('import', 'T')
      T_C = VirtualConnectionPt('import', 'T')
      T_D = VirtualConnectionPt('import', 'T')

      call r_A%add_item_spec(T_A, MockItemSpec('T_A'))
      call r_C%add_item_spec(T_C, MockItemSpec('T_C'))
      call r_D%add_item_spec(T_D, MockItemSpec('T_D'))

      ! i2i
      call r_B%propagate_unsatisfied_imports()
      extension_pt = ActualConnectionPt('import/<extensions>/<C>/T')
      @assert_that(r_B%has_item_spec(extension_pt), is(true()))

      ! sibling
      call r_P%add_connection(ConnectionSpec(CP('A',T_A), CP('B', T_B)))
      
   end subroutine test_multi_import


end module Test_HierarchicalRegistry
