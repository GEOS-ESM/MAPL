module Test_HierarchicalRegistry
   use funit
   use mapl3g_AbstractRegistry
   use mapl3g_HierarchicalRegistry
   use mapl3g_AbstractStateItemSpec
   use mapl3g_ConnectionPt
   use mapl3g_ActualPtVector
   use mapl3g_newVirtualConnectionPt
   use mapl3g_newActualConnectionPt
   use mapl3g_ConnectionSpec
   use mapl3g_AbstractActionSpec
   use MockItemSpecMod
   implicit none

   interface check
      module procedure check_actual
      module procedure check_virtual
   end interface check


#define CP(x,y)  ConnectionPt(x,y)
contains

   ! We want client code to be careful, but requiring keywords is
   ! annoying in this context.
   function new_a_pt(state_intent, short_name) result(a_pt)
      type(newActualConnectionPt) :: a_pt
      character(*), intent(in) :: state_intent, short_name
      a_pt = newActualConnectionPt(new_v_pt(state_intent,short_name))
   end function new_a_pt
      
   function new_v_pt(state_intent, short_name) result(v_pt)
      type(newVirtualConnectionPt) :: v_pt
      character(*), intent(in) :: state_intent, short_name
      v_pt = newVirtualConnectionPt(state_intent=state_intent, short_name=short_name)
   end function new_v_pt

   ! Helpful function to check expected state of registry.  Inputs are
   ! a registry, an actual point, and expected name of mock object.
   logical function check_actual(r, actual_pt, expected_name) result(check)
      type(HierarchicalRegistry), intent(in) :: r 
      type(newActualConnectionPt), intent(in) :: actual_pt
      character(*), intent(in) :: expected_name

      class(AbstractStateItemSpec), pointer :: spec
      check = .false.
      spec => r%get_item_spec(actual_pt)
      @assert_that(associated(spec), is(true()))

      select type(spec)
      type is (MockItemSpec)
         @assertEqual(expected_name, spec%name)
         check = .true.
      class default
         @assert_that(1,is(2))
      end select
   end function check_actual

   ! Helpful function to check expected state of registry.  Inputs are
   ! a registry, a virtual point, and expected name of mock object.
   logical function check_virtual(r, virtual_pt, expected_names) result(check)
      type(HierarchicalRegistry), intent(in) :: r 
      type(newVirtualConnectionPt), intent(in) :: virtual_pt
      character(*), intent(in) :: expected_names(:)

      type(ActualPtVector), pointer :: actual_pts
      type(newActualConnectionPt), pointer :: actual_pt
      integer :: i
      
      check = .false.
      actual_pts => r%get_actual_pts(virtual_pt)
      @assert_that(associated(actual_pts), is(true()))

      do i = 1, actual_pts%size()
         actual_pt => actual_pts%of(i)
         check = check_actual(r, actual_pt, expected_names(i))
      end do
   end function check_virtual


   @test
   subroutine test_get_item_spec_not_found()

      type(HierarchicalRegistry) :: r
      class(AbstractStateItemSpec), pointer :: spec

      r = HierarchicalRegistry('A')
      spec => r%get_item_spec(new_a_pt('import', 'a'))
      @assertExceptionRaised('status=1')
      @assert_that(associated(spec), is(false()))
      
   end subroutine test_get_item_spec_not_found
   
   @test
   subroutine test_add_item_duplicate_fail()
      type(HierarchicalRegistry) :: r
      integer :: status
      type(newActualConnectionPt) :: cp

      r = HierarchicalRegistry('A')

      cp = new_a_pt('A','A')
      call r%add_item_spec(cp, MockItemSpec('A'), rc=status)
      @assert_that(status, is(0))
      call r%add_item_spec(cp, MockItemSpec('A'), rc=status)
      @assertExceptionRaised('Duplicate item name.')
      @assert_that(status, is(not(0)))

   end subroutine test_add_item_duplicate_fail
   

   @test
   subroutine test_get_item_spec_found()
      type(HierarchicalRegistry) :: r
      class(AbstractStateItemSpec), pointer :: spec
      type(newActualConnectionPt) :: cp

      r = HierarchicalRegistry('A')
      cp = new_a_pt('import','a')
      call r%add_item_spec(cp, MockItemSpec('A'))

      spec => r%get_item_spec(cp)
      @assert_that(associated(spec), is(true()))
      if (.not. check(r, cp, 'A')) return

   end subroutine test_get_item_spec_found



   @test
   ! Add multiple specs and check that the correct spec is returned by
   ! name.
   subroutine test_get_item_spec_multi()
      type(HierarchicalRegistry) :: r 
      type(newActualConnectionPt) :: cp_1, cp_2, cp_3

      cp_1 = new_a_pt('export', 'ae1')
      cp_2 = new_a_pt('export', 'ae2')
      cp_3 = new_a_pt('import', 'ai')

      r = HierarchicalRegistry('A')
      call r%add_item_spec(cp_1, MockItemSpec('AE1'))
      call r%add_item_spec(cp_2, MockItemSpec('AE2'))
      call r%add_item_spec(cp_3, MockItemSpec('AI'))

      if (.not. check(r, cp_1, 'AE1')) return
      if (.not. check(r, cp_2, 'AE2')) return
      if (.not. check(r, cp_3, 'AI'))return

   end subroutine test_get_item_spec_multi

   @test
   subroutine test_get_subregistry()
      type(HierarchicalRegistry), target :: child_registry
      type(HierarchicalRegistry), target :: r
      class(AbstractRegistry), pointer :: ptr
      
      r = HierarchicalRegistry('parent')
      child_registry = HierarchicalRegistry('child')
      call r%add_subregistry(child_registry)

      ptr => r%get_subregistry('child')
      @assert_that(associated(ptr), is(true()))

   end subroutine test_get_subregistry


   @test
   subroutine test_get_subregistry_fail_not_found()
      type(HierarchicalRegistry), target :: child_registry
      type(HierarchicalRegistry), target :: r
      class(AbstractRegistry), pointer :: ptr

      integer :: status

      child_registry = HierarchicalRegistry('A')
      r = HierarchicalRegistry('parent')
      
      call r%add_subregistry(child_registry)
      ptr => r%get_subregistry('B', rc=status)
      @assertExceptionRaised('status=1')
      @assert_that(status, is(not(0)))
      @assert_that(associated(ptr), is(false()))
      
   end subroutine test_get_subregistry_fail_not_found


   @test
   ! Very simple sibling connection
   subroutine test_connect()
      type(HierarchicalRegistry) :: r
      type(HierarchicalRegistry), target :: r_A, r_B ! child registries
      type(newVirtualConnectionPt) :: cp_A, cp_B
      type(ConnectionSpec) :: conn
      integer :: status

      r = HierarchicalRegistry('P')
      r_a = HierarchicalRegistry('child_A')
      r_b = HierarchicalRegistry('child_B')
      call r%add_subregistry(r_a)
      call r%add_subregistry(r_b)

      cp_A = new_v_pt('export', 'ae')
      cp_B = new_v_pt('import', 'ai')

      call r_a%add_item_spec(cp_A, MockItemSpec('AE'))
      call r_b%add_item_spec(cp_B, MockItemSpec('AI'))

      conn = ConnectionSpec(CP('child_A', cp_A), CP('child_B', cp_B))
      call r%add_connection(conn, rc=status)
      @assert_that(status, is(0))

      if (.not. check(r_b, cp_B, ['AE'])) return

   end subroutine test_connect

   @test
   subroutine test_export_to_export_connection()
      type(HierarchicalRegistry) :: r
      type(HierarchicalRegistry), target :: r_A
      type(newVirtualConnectionPt) :: cp_1, cp_2

      integer :: status

      r = HierarchicalRegistry('R')
      r_A = HierarchicalRegistry('A')
      call r%add_subregistry(r_A)

      cp_1 = new_v_pt('export', 'ae1')
      cp_2 = new_v_pt('export', 'ae2')

      ! True export
      call r_A%add_item_spec(cp_1, MockItemSpec('AE1'))

      ! E-to-E with rename
      call r%add_connection(ConnectionSpec(CP('A',cp_1), CP('R',cp_2)), rc=status)
      @assert_that(status, is(0))

      if (.not. check(r, cp_2, ['AE1'])) return

   end subroutine test_export_to_export_connection

   @test
   subroutine test_internal_to_export_connection()
      type(HierarchicalRegistry), target :: r
      type(newVirtualConnectionPt) :: cp_1, cp_2
      class(AbstractStateItemSpec), pointer :: spec

      integer :: status

      r = HierarchicalRegistry('R')
      cp_1 = new_v_pt('internal', 'a')
      cp_2 = new_v_pt('export', 'a')

      ! True export
      call r%add_item_spec(cp_1, MockItemSpec('AE1'))

      ! Internal-to-export
      call r%add_connection(ConnectionSpec(CP('R',cp_1), CP('R',cp_2)), rc=status)
      @assert_that(status, is(0))

      if (.not. check(r, cp_2, ['AE1'])) return

      ! Internal is always active, so this export should be as well:
      spec => r%get_item_spec(newActualConnectionPt(cp_2))
      @assert_that(spec%is_active(), is(true()))

   end subroutine test_internal_to_export_connection


   @test
   ! For E2E, we expect the parent actual_pt to be the one specified by the connection,
   ! rather than the one specified by the child.  This is in addition to the analogous
   ! assumption about the virtual pt, which is verified in the previous test.
   subroutine test_e2e_preserve_actual_pt()
      type(HierarchicalRegistry), target :: r
      type(HierarchicalRegistry), target :: r_A
      type(newVirtualConnectionPt) :: cp_1, cp_2

      integer :: status

      r = HierarchicalRegistry('R')
      r_A = HierarchicalRegistry('A')
      call r%add_subregistry(r_A)

      cp_1 = new_v_pt('export', 'ae1')
      cp_2 = new_v_pt('export', 'ae2')

      ! True export
      call r_A%add_item_spec(cp_1, MockItemSpec('AE1'))

      ! E-to-E with rename
      call r%add_connection(ConnectionSpec(CP('A',cp_1), CP('R',cp_2)), rc=status)

      @assert_that(r%has_item_spec(newActualConnectionPt(cp_2%add_comp_name('A'))), is(true()))

   end subroutine test_e2e_preserve_actual_pt

   
   @test
   ! This procedure testss an "E-to-E" style connection that
   ! propagates an export from a child to a parent.  (Grandchild to
   ! component "A" in this case.)
   ! A sibling connection is then made at the grandparent level and we check
   ! that the original export is indeed activated.
   subroutine test_connect_chain()
      type(HierarchicalRegistry) :: r
      type(HierarchicalRegistry), target :: r_A, r_B, r_grandchild
      type(newVirtualConnectionPt) :: cp_1, cp_2, cp_3

      integer :: status

      r = HierarchicalRegistry('R')
      r_grandchild = HierarchicalRegistry('grandchild')
      r_A = HierarchicalRegistry('A')
      r_B = HierarchicalRegistry('B')
      
      call r_A%add_subregistry(r_grandchild)
      call r%add_subregistry(r_A)
      call r%add_subregistry(r_B)

      cp_1 = new_v_pt('export', 'ae1')
      cp_2 = new_v_pt('export', 'ae2')
      cp_3 = new_v_pt('import', 'ai')

      call r_grandchild%add_item_spec(cp_1, MockItemSpec('AE1'))
      call r_B%add_item_spec(cp_3, MockItemSpec('AI'))

      ! E-to-E
      call r_A%add_connection(ConnectionSpec(CP('grandchild',cp_1), CP('A',cp_2)), rc=status)
      @assert_that(status, is(0))
      ! sibling
      call r%add_connection(ConnectionSpec(CP('A',cp_2), CP('B', cp_3)), rc=status)
      @assert_that(status, is(0))

      if (.not. check(r_B, cp_3, ['AE1'])) return

   end subroutine test_connect_chain


   @test
   ! Verify that sibling connections set active status, but not others.
   subroutine test_sibling_activation()
      type(HierarchicalRegistry), target :: r
      type(HierarchicalRegistry), target :: r_A, r_B, r_P, r_C
      class(AbstractStateItemSpec), pointer :: spec

      type(newVirtualConnectionPt) :: cp_1, cp_2, cp_4
      type(ConnectionSpec) :: e2e, sib

      r = HierarchicalRegistry('R')
      r_P = HierarchicalRegistry('P')
      r_A = HierarchicalRegistry('A')
      r_B = HierarchicalRegistry('B')
      r_C = HierarchicalRegistry('C')

      call r%add_subregistry(r_P)
      call r%add_subregistry(r_B)

      call r_P%add_subregistry(r_A)
      call r_B%add_subregistry(r_C)

      cp_1 = new_v_pt('export', 'A1')
      cp_2 = new_v_pt('export', 'A2')
      cp_4 = new_v_pt('import', 'A4')

      call r_A%add_item_spec(cp_1, MockItemSpec('name:A1'))
      call r_C%add_item_spec(cp_4, MockItemSpec('name:A4'))

        !-------------------------------------------
        !
        !                    sib*
        !          P  cp_2   --->    cp_4*  B   
        !              ^              |
        !     e2e      |              |     i2i (implicit)
        !              |              V
        !          A  cp_1           cp_4  C
        !
        !-------------------------------------------
      e2e = ConnectionSpec(CP('A',cp_1), CP('P',cp_2))
      sib = ConnectionSpec(CP('P',cp_2), CP('B', cp_4))

      spec => r_A%get_item_spec(newActualConnectionPt(cp_1)) ! ultimate export
      @assert_that(spec%is_active(), is(false()))

      call r_P%add_connection(e2e)
      @assert_that(spec%is_active(), is(false()))
      if (.not. check(r_P, cp_2, ['name:A1'])) return
      call r_B%propagate_unsatisfied_imports()

      ! 1 => A, 2 => A, 3 => C, 4 => D

      call r%add_connection(sib)

      spec => r_A%get_item_spec(newActualConnectionPt(cp_1))
      @assert_that('cp_1', spec%is_active(), is(true()))
      
      spec => r_P%get_item_spec(newActualConnectionPt(cp_2%add_comp_name('A')))
      @assert_that(spec%is_active(), is(true()))

      spec => r_B%get_item_spec(newActualConnectionPt(cp_4%add_comp_name('C')))
      @assert_that(spec%is_active(), is(true()))
      
      spec => r_C%get_item_spec(newActualConnectionPt(cp_4))
      @assert_that('cp_4', spec%is_active(), is(true()))
      
   end subroutine test_sibling_activation
          
       
   @test
   ! Internal state items are always active
   subroutine test_internal_activation()
      type(HierarchicalRegistry) :: r
      class(AbstractStateItemSpec), pointer :: spec

      type(newActualConnectionPt) :: cp_1, cp_2, cp_3
           cp_1 = new_a_pt('internal', 'A')
           cp_2 = new_a_pt('export', 'A')
           cp_3 = new_a_pt('import', 'A')

        call r%add_item_spec(cp_1, MockItemSpec('A1'))
        call r%add_item_spec(cp_2, MockItemSpec('A2'))
        call r%add_item_spec(cp_3, MockItemSpec('A3'))

        spec => r%get_item_spec(cp_1)
        @assert_that(spec%is_active(), is(true()))
        
        spec => r%get_item_spec(cp_2)
        @assert_that(spec%is_active(), is(false()))
        
        spec => r%get_item_spec(cp_3)
        @assert_that(spec%is_active(), is(false()))
        
   end subroutine test_internal_activation
          
   @test
   ! Verify that an extension is created when an export is
   ! semi-compatible with an import.
   subroutine test_create_extension()
      type(HierarchicalRegistry), target :: r_A, r_B
      class(AbstractStateItemSpec), pointer :: dst_spec, src_spec
      class(AbstractActionSpec), allocatable :: action_spec

      type(newActualConnectionPt) :: e1, i1

      e1 = new_a_pt('export', 'Q')
      i1 = new_a_pt('import', 'Q')
      call r_A%add_item_spec(e1, MockItemSpec('E1','fruit'))
      call r_B%add_item_spec(i1, MockItemSpec('I1','animal'))

      src_spec => r_A%get_item_spec(e1)
      dst_spec => r_B%get_item_spec(i1)

      @assert_that((dst_spec%can_connect_to(src_spec)), is(true()))
      @assert_that((dst_spec%requires_extension(src_spec)), is(true()))

      action_spec = src_spec%make_extension(dst_spec)
      select type (action_spec)
      type is (MockActionSpec)
         @assertEqual('fruit ==> animal', action_spec%details)
      class default
         @assert_that(1, is(2))
      end select
      
   end subroutine test_create_extension


        !-------------------------------------------
        !
        !              parent
        !                |
        !                |
        !                |
        !              child   (import, T)
        !
        !-------------------------------------------
   @test
   subroutine test_propagate_import()
      type(HierarchicalRegistry), target :: r_child, r_parent

      integer :: status
      type(newVirtualConnectionPt) :: c_pt
      
      
      r_parent = HierarchicalRegistry('parent')
      r_child = HierarchicalRegistry('child')
      call r_parent%add_subregistry(r_child)

      c_pt = new_v_pt('import', 'T')
      call r_child%add_item_spec(c_pt, MockItemSpec('T_child'))
      call r_parent%propagate_unsatisfied_imports(rc=status)

      @assert_that(status, is(0))
      @assert_that(r_parent%has_item_spec(new_v_pt('import', 'T')), is(true()))
      @assert_that(r_parent%has_item_spec(newActualConnectionPt(c_pt%add_comp_name('child'))), is(true()))
      
   end subroutine test_propagate_import

   ! If a parent has two children that both need the same import (as
   ! determined by short name), then extensions must be used to
   ! represent both.

        !-------------------------------------------
        !
        !                  sib*
        !              A   --->     B
        !                          / \  
        !                         /   \      i2i (implicit)
        !                        /     \
        !                       C       D
        !
        !-------------------------------------------

   ! We expect B to have a virtual pt with 2 actual pts from children.
   ! We also expect export from A to satisfy both imports.

   @test
   subroutine test_multi_import()
      type(HierarchicalRegistry), target :: r_C, r_D, r_A, r_B
      type(HierarchicalRegistry) :: r_P 
      type(newVirtualConnectionPt) :: T_A, T_B, T_C, T_D
      class(AbstractStateItemSpec), pointer :: spec

      r_A = HierarchicalRegistry('A')
      r_B = HierarchicalRegistry('B')
      r_C = HierarchicalRegistry('C')
      r_D = HierarchicalRegistry('D')
      r_P = HierarchicalRegistry('parent')
      
      call r_B%add_subregistry(r_C)
      call r_B%add_subregistry(r_D)
      call r_P%add_subregistry(r_A)
      call r_P%add_subregistry(r_B)

      T_A = new_v_pt('export', 'T')
      T_B = new_v_pt('import', 'T')
      T_C = new_v_pt('import', 'T')
      T_D = new_v_pt('import', 'T')

      call r_A%add_item_spec(T_A, MockItemSpec('T_A'))
      call r_C%add_item_spec(T_C, MockItemSpec('T_C'))
      call r_D%add_item_spec(T_D, MockItemSpec('T_D'))

      ! i2i
      call r_B%propagate_unsatisfied_imports()

      ! sibling
      call r_P%add_connection(ConnectionSpec(CP('A',T_A), CP('B', T_B)))

      ! Export should be active
      spec => r_A%get_item_spec(new_a_pt('export', 'T'))
      @assert_that(spec%is_active(), is(true()))

      ! Primary imports should be active
      spec => r_C%get_item_spec(new_a_pt('import', 'T'))
      @assert_that(spec%is_active(), is(true()))
      
      spec => r_D%get_item_spec(new_a_pt('import', 'T'))
      @assert_that(spec%is_active(), is(true()))

      ! Secondary imports should be active
      spec => r_B%get_item_spec(newActualConnectionPt(T_C%add_comp_name('C')))
      @assert_that(spec%is_active(), is(true()))
      
      spec => r_B%get_item_spec(newActualConnectionPt(T_D%add_comp_name('D')))
      @assert_that(spec%is_active(), is(true()))
      
      
   end subroutine test_multi_import


   @test
   ! This functionality was referred to as "TerminateImport" in
   ! MAPL-2.  Under MAPL3, the parent must have an export and a proper
   ! "sibling" connection is made between parent and child.  The
   ! approach in MAPL-2 was invalid in scenarios where parent and
   ! child cannot share a pointer.  Grid-comps must be updated. (Level
   ! 0 compliance.)
   
   subroutine test_import_from_parent()
      type(HierarchicalRegistry), target :: r_parent, r_child
      type(newVirtualConnectionPt) :: cp_parent, cp_child
      type(ConnectionSpec) :: conn
      integer :: status

      r_parent = HierarchicalRegistry('parent')
      r_child = HierarchicalRegistry('child')
      call r_parent%add_subregistry(r_child)

      cp_parent = new_v_pt('export', 'ae')
      cp_child = new_v_pt('import', 'ai')

      call r_parent%add_item_spec(cp_parent, MockItemSpec('AE'))
      call r_child%add_item_spec(cp_child, MockItemSpec('AI'))

      conn = ConnectionSpec(CP('parent', cp_parent), CP('child', cp_child))
      call r_parent%add_connection(conn, rc=status)
      @assert_that(status, is(0))

      if (.not. check(r_child, cp_child, ['AE'])) return

   end subroutine test_import_from_parent

   @test

   ! This functionality was implicit in MAPL2.  Parent components
   ! would either refer to fields in child components, or would use an
   ! export-to-export connection and then access the field in its own
   ! export state.  Both approaches are invalid under scenarios where
   ! parent and child cannot share a pointer.  Grid comps will need to
   ! be updated. (Level 0 compliance.)
   
   subroutine test_import_from_child()
      type(HierarchicalRegistry), target :: r_parent, r_child
      type(newVirtualConnectionPt) :: cp_parent, cp_child
      type(ConnectionSpec) :: conn
      integer :: status

      r_parent = HierarchicalRegistry('parent')
      r_child = HierarchicalRegistry('child')
      call r_parent%add_subregistry(r_child)

      cp_parent = new_v_pt('import', 'ai')
      cp_child = new_v_pt('export', 'ae')

      call r_parent%add_item_spec(cp_parent, MockItemSpec('AI'))
      call r_child%add_item_spec(cp_child, MockItemSpec('AE'))

      conn = ConnectionSpec(CP('child', cp_child), CP('parent', cp_parent))
      call r_parent%add_connection(conn, rc=status)
      @assert_that(status, is(0))

      if (.not. check(r_parent, cp_parent, ['AE'])) return

   end subroutine test_import_from_child

end module Test_HierarchicalRegistry
