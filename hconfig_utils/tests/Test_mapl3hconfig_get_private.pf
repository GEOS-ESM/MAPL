module Test_mapl3hconfig_get_private
   use mapl3hconfig_get_private
   use ESMF
   use pfunit

   implicit none

   ! error message stubs
   character(len=*), parameter :: ERROR_GET_HCONFIG_FAILED = 'get_HConfig failed.'
   character(len=*), parameter :: ERROR_ADD_FAIL = 'Add failed.'
   character(len=*), parameter :: ERROR_NOT_FOUND = 'Find failed for: '
   character(len=*), parameter :: ERROR_MISMATCH = 'actual does not match expected.'
   character, parameter :: SPACE = ' '
   integer, parameter :: MAXSTRLEN = ESMF_MAXSTR

   ! instance variables
   logical :: hconfig_is_created = .FALSE.
   type(ESMF_HConfig) :: hconfig

contains

   @Test
   subroutine test_get_i4()
      character(len=*), parameter :: KEY = 'inv_alpha'
      character(len=*), parameter :: EXPECTED_TYPESTRING = 'I4'
      character(len=*), parameter :: EXPECTED_VALUESTRING = '137'
      integer(kind=ESMF_KIND_I4), parameter :: EXPECTED = 137
      integer(kind=ESMF_KIND_I4) :: actual
      character(len=:), allocatable :: typestring
      character(len=:), allocatable :: valuestring
      logical :: found
      integer :: status

      call ESMF_HConfigAdd(hconfig, EXPECTED, addKeyString=KEY, rc=status)
      @assertEqual(0, status, ERROR_ADD_FAIL)
      call get_value(hconfig, KEY, actual, found=found, typestring=typestring, valuestring=valuestring, rc=status)
      @assertEqual(0, status, ERROR_GET_HCONFIG_FAILED)
      @assertTrue(found, ERROR_NOT_FOUND // KEY)
      @assertTrue(actual == EXPECTED, ERROR_MISMATCH)
      @assertEqual(EXPECTED_TYPESTRING, typestring, make_mismatch_error_message(EXPECTED_TYPESTRING, typestring))
      @assertEqual(EXPECTED_VALUESTRING, valuestring, make_mismatch_error_message(EXPECTED_VALUESTRING, valuestring))

   end subroutine test_get_i4

   @Test
   subroutine test_get_i8()
      character(len=*), parameter :: KEY = 'num_h_on_pinhead'
      character(len=*), parameter :: EXPECTED_TYPESTRING = 'I8'
      character(len=*), parameter :: EXPECTED_VALUESTRING = '50000000000'
      integer(kind=ESMF_KIND_I8), parameter :: EXPECTED = 50000000000
      integer(kind=ESMF_KIND_I8) :: actual
      character(len=:), allocatable :: typestring
      character(len=:), allocatable :: valuestring
      logical :: found
      integer :: status

      call ESMF_HConfigAdd(hconfig, EXPECTED, addKeyString=KEY, rc=status)
      @assertEqual(0, status, ERROR_ADD_FAIL)
      call get_value(hconfig, KEY, actual, found=found, typestring=typestring, valuestring=valuestring, rc=status)
      @assertEqual(0, status, ERROR_GET_HCONFIG_FAILED)
      @assertTrue(found, ERROR_NOT_FOUND // KEY)
      @assertTrue(actual == EXPECTED, make_mismatch_error_message(actual, EXPECTED)) 
      @assertEqual(EXPECTED_TYPESTRING, typestring, make_mismatch_error_message(EXPECTED_TYPESTRING, typestring))
      @assertEqual(EXPECTED_VALUESTRING, valuestring, make_mismatch_error_message(EXPECTED_VALUESTRING, valuestring))

   end subroutine test_get_i8
   
   @Test
   subroutine test_get_r4()
      character(len=*), parameter :: KEY = 'plank_mass'
      character(len=*), parameter :: EXPECTED_TYPESTRING = 'R4'
      character(len=*), parameter :: EXPECTED_VALUESTRING = '1.8590000E-09'
      real(kind=ESMF_KIND_R4), parameter :: EXPECTED =   1.85900000E-9_ESMF_KIND_R4
      real(kind=ESMF_KIND_R4) :: actual
      character(len=:), allocatable :: typestring
      character(len=:), allocatable :: valuestring
      logical :: found
      integer :: status

      call ESMF_HConfigAdd(hconfig, EXPECTED, addKeyString=KEY, rc=status)
      @assertEqual(0, status, ERROR_ADD_FAIL)
      call get_value(hconfig, KEY, actual, found=found, typestring=typestring, valuestring=valuestring, rc=status)
      @assertEqual(0, status, ERROR_GET_HCONFIG_FAILED)
      @assertTrue(found, ERROR_NOT_FOUND // KEY)
      @assertTrue(actual == EXPECTED, make_mismatch_error_message(actual, EXPECTED)) 
      @assertEqual(EXPECTED_TYPESTRING, typestring, make_mismatch_error_message(EXPECTED_TYPESTRING, typestring))
      @assertEqual(EXPECTED_VALUESTRING, valuestring, make_mismatch_error_message(EXPECTED_VALUESTRING, valuestring))

   end subroutine test_get_r4
   
   @Test
   subroutine test_get_r8()
      character(len=*), parameter :: KEY = 'mu_mass'
      character(len=*), parameter :: EXPECTED_TYPESTRING = 'R8'
      character(len=*), parameter :: EXPECTED_VALUESTRING =   '-9.284764704320000E-23'
      real(kind=ESMF_KIND_R8), parameter :: EXPECTED = -9.28476470432000000E-23_ESMF_KIND_R8
      real(kind=ESMF_KIND_R8) :: actual
      character(len=:), allocatable :: typestring
      character(len=:), allocatable :: valuestring
      logical :: found
      integer :: status

      call ESMF_HConfigAdd(hconfig, EXPECTED, addKeyString=KEY, rc=status)
      @assertEqual(0, status, ERROR_ADD_FAIL)
      call get_value(hconfig, KEY, actual, found=found, typestring=typestring, valuestring=valuestring, rc=status)
      @assertEqual(0, status, ERROR_GET_HCONFIG_FAILED)
      @assertTrue(found, ERROR_NOT_FOUND // KEY)
      @assertTrue(actual == EXPECTED, make_mismatch_error_message(actual, EXPECTED)) 
      @assertEqual(EXPECTED_TYPESTRING, typestring, make_mismatch_error_message(EXPECTED_TYPESTRING, typestring))
      @assertEqual(EXPECTED_VALUESTRING, valuestring, make_mismatch_error_message(EXPECTED_VALUESTRING, valuestring))

   end subroutine test_get_r8

   @Test
   subroutine test_get_logical()
      character(len=*), parameter :: KEY = 'p_or_np'
      character(len=*), parameter :: EXPECTED_TYPESTRING = 'L'
      character(len=*), parameter :: EXPECTED_VALUESTRING = 'T'
      logical, parameter :: EXPECTED = .TRUE.
      logical :: actual
      character(len=:), allocatable :: typestring
      character(len=:), allocatable :: valuestring
      logical :: found
      integer :: status

      call ESMF_HConfigAdd(hconfig, EXPECTED, addKeyString=KEY, rc=status)
      @assertEqual(0, status, ERROR_ADD_FAIL)
      call get_value(hconfig, KEY, actual, found=found, typestring=typestring, valuestring=valuestring, rc=status)
      @assertEqual(0, status, ERROR_GET_HCONFIG_FAILED)
      @assertTrue(found, ERROR_NOT_FOUND // KEY)
      @assertTrue(EXPECTED .eqv. actual, make_mismatch_error_message(actual, EXPECTED)) 
      @assertEqual(EXPECTED_TYPESTRING, typestring, make_mismatch_error_message(EXPECTED_TYPESTRING, typestring))
      @assertEqual(EXPECTED_VALUESTRING, valuestring, make_mismatch_error_message(EXPECTED_VALUESTRING, valuestring))

   end subroutine test_get_logical

   @Test
   subroutine test_get_string()
      character(len=*), parameter :: KEY = 'newton'
      character(len=*), parameter :: EXPECTED_TYPESTRING = 'CH'
      character(len=*), parameter :: EXPECTED_VALUESTRING = '"Fg = Gm1m2/r^2"'
      character(len=*), parameter :: EXPECTED = 'Fg = Gm1m2/r^2'
      character(len=MAXSTRLEN) :: actual
      character(len=:), allocatable :: typestring
      character(len=:), allocatable :: valuestring
      logical :: found
      integer :: status

      call ESMF_HConfigAdd(hconfig, EXPECTED, addKeyString=KEY, rc=status)
      @assertEqual(0, status, ERROR_ADD_FAIL)
      call get_value(hconfig, KEY, actual, found=found, typestring=typestring, valuestring=valuestring, rc=status)
      @assertEqual(0, status, ERROR_GET_HCONFIG_FAILED)
      @assertTrue(found, ERROR_NOT_FOUND // KEY)
      @assertTrue(actual == EXPECTED, make_mismatch_error_message(actual, EXPECTED)) 
      @assertEqual(EXPECTED_TYPESTRING, typestring, make_mismatch_error_message(EXPECTED_TYPESTRING, typestring))
      @assertEqual(EXPECTED_VALUESTRING, valuestring, make_mismatch_error_message(valuestring, EXPECTED_VALUESTRING))

   end subroutine test_get_string

   @Test
   subroutine test_get_i4seq()
      character(len=*), parameter :: KEY = 'four_vector'
      character(len=*), parameter :: EXPECTED_TYPESTRING = 'I4'
      character(len=*), parameter :: EXPECTED_VALUESTRING = '-1 1 0 0'
      integer(kind=ESMF_KIND_I4), parameter :: EXPECTED(4) = [-1, 1, 0, 0]
      integer(kind=ESMF_KIND_I4) :: actual(4)
      character(len=:), allocatable :: typestring
      character(len=:), allocatable :: valuestring
      logical :: found
      integer :: status

      call ESMF_HConfigAdd(hconfig, EXPECTED, addKeyString=KEY, rc=status)
      @assertEqual(0, status, ERROR_ADD_FAIL)
      call get_value(hconfig, KEY, actual, found=found, typestring=typestring, valuestring=valuestring, rc=status)
      @assertEqual(0, status, ERROR_GET_HCONFIG_FAILED)
      @assertTrue(found, ERROR_NOT_FOUND // KEY)
      @assertTrue(actual == EXPECTED, ERROR_MISMATCH)
      @assertEqual(EXPECTED_TYPESTRING, typestring, make_mismatch_error_message(EXPECTED_TYPESTRING, typestring))
      @assertEqual(EXPECTED_VALUESTRING, valuestring, make_mismatch_error_message(valuestring, EXPECTED_VALUESTRING))
   end subroutine test_get_i4seq

   @Test
   subroutine test_get_i8seq()
      character(len=*), parameter :: KEY = 'quaternion'
      character(len=*), parameter :: EXPECTED_TYPESTRING = 'I8'
      character(len=*), parameter :: EXPECTED_VALUESTRING = '-1 1 0 0'
      integer(kind=ESMF_KIND_I8), parameter :: EXPECTED(4) = [-1, 1, 0, 0]
      integer(kind=ESMF_KIND_I8) :: actual(4)
      character(len=:), allocatable :: typestring
      character(len=:), allocatable :: valuestring
      logical :: found
      integer :: status

      call ESMF_HConfigAdd(hconfig, EXPECTED, addKeyString=KEY, rc=status)
      @assertEqual(0, status, ERROR_ADD_FAIL)
      call get_value(hconfig, KEY, actual, found=found, typestring=typestring, valuestring=valuestring, rc=status)
      @assertEqual(0, status, ERROR_GET_HCONFIG_FAILED)
      @assertTrue(found, ERROR_NOT_FOUND // KEY)
      @assertTrue(actual == EXPECTED, ERROR_MISMATCH)
      @assertEqual(EXPECTED_TYPESTRING, typestring, make_mismatch_error_message(EXPECTED_TYPESTRING, typestring))
      @assertEqual(EXPECTED_VALUESTRING, valuestring, make_mismatch_error_message(valuestring, EXPECTED_VALUESTRING))
   end subroutine test_get_i8seq

   @Before
   subroutine set_up()
      
      integer :: status

      if(.not. hconfig_is_created) then
         hconfig = ESMF_HConfigCreate(rc=status)
         hconfig_is_created = (status == 0)
      end if
      @assertTrue(hconfig_is_created, 'HConfig was not created.')

   end subroutine set_up

   @After
   subroutine tear_down()

      integer :: status

      if(hconfig_is_created) call ESMF_HConfigDestroy(hconfig, rc=status)
      hconfig_is_created = .FALSE.
      @assertFalse(hconfig_is_created, 'HConfig was not destroyed.')

   end subroutine tear_down

   function make_mismatch_error_message(actual, expected, prolog, bridge, epilog) result(error_message)
      character(len=:), allocatable :: error_message
      class(*), intent(in) :: actual, expected
      character(len=*), optional, intent(in) :: prolog, bridge, epilog
      character(len=:), allocatable :: actual_string, expected_string
      character(len=:), allocatable :: prolog_, epilog_, bridge_

      if(present(prolog)) then
         prolog_ = trim(adjustl(prolog)) // SPACE
      else
         prolog_ = ''
      end if

      if(present(epilog)) then
         epilog_ = SPACE // trim(adjustl(epilog))
      else
         epilog_ = ''
      end if

      if(present(bridge)) then
         bridge_ = SPACE // trim(adjustl(bridge)) // SPACE
      else
         bridge_ = ' does not match '
      end if

      if(same_type_as(actual, expected)) then
         actual_string = write_valuestring(actual)
         expected_string = write_valuestring(expected)
         error_message = prolog_ // actual_string // bridge_ // expected_string // epilog_
      else
         error_message = 'actual and expected are different types.'
      endif

   end function make_mismatch_error_message

   function write_valuestring(value) result(valuestring)
      character(len=:), allocatable :: valuestring
      class(*), intent(in) :: value
      character(len=MAXSTRLEN) :: rawstring
      integer :: ios

      select type(value)
      type is (integer(kind=ESMF_KIND_I4))
         write(rawstring, fmt='(I32)', iostat=ios) value
      type is (integer(kind=ESMF_KIND_I8))
         write(rawstring, fmt='(I32)', iostat=ios) value
      type is (real(kind=ESMF_KIND_R4))
         write(rawstring, fmt='(G32.16)', iostat=ios) value
      type is (real(kind=ESMF_KIND_R8))
         write(rawstring, fmt='(G32.16)', iostat=ios) value
      type is (logical)
         write(rawstring, fmt='(L1)', iostat=ios) value
      type is (character(len=*))
         rawstring = value
         ios = 0
      end select
      
      if(ios==0) then
         valuestring = trim(adjustl(rawstring))
      else
         valuestring = ''
      end if
      
   end function write_valuestring

end module Test_mapl3hconfig_get_private
