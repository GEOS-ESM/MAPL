#include "MAPL_Exceptions.h"
#include "MAPL_ErrLog.h"
! These tests should only run when you are debugging.
!===============================================================================
! TEST_MAPL_NETCDF_PRIVATE
!===============================================================================
module test_MAPL_NetCDF_private

   use MAPL_NetCDF
   use test_MAPL_NetCDF_helpers
   use MAPL_ExceptionHandling
   use ESMF
   use pfunit

   implicit none

contains

   @Test
   subroutine test_make_ESMF_TimeInterval_integer()
      character(len=*), parameter :: units = 'seconds'
      character(len=*), parameter :: iso_string = '2013-08-26T12:34:56'
      integer, parameter :: duration = 1800
      type(ESMF_TimeInterval) :: expected_interval
      type(ESMF_Time) :: start_time
      type(ESMF_TimeInterval) :: interval
      integer :: rc, status

      call ESMF_TimeSet(start_time, iso_string, _RC)
      call ESMF_TimeIntervalSet(expected_interval, startTime=start_time, s=duration, _RC)
      call make_ESMF_TimeInterval(duration, units, start_time, interval, _RC)
      @assertTrue(expected_interval == interval, 'ESMF_TimeInterval variables do not match.')

   end subroutine test_make_ESMF_TimeInterval_integer

   @Test
   subroutine test_make_NetCDF_DateTime_duration_integer()
      character(len=*), parameter :: tunit = 'seconds'
      character(len=*), parameter :: iso_string = '2013-08-26T12:34:56'
      type(ESMF_TimeInterval) :: interval
      type(ESMF_Time) :: start_time
      integer, parameter :: expected_duration = 1800
      integer :: duration
      integer :: status, rc

      call ESMF_TimeSet(start_time, iso_string, _RC)
      call ESMF_TimeIntervalSet(interval, startTime=start_time, s=expected_duration, _RC)

      call make_NetCDF_DateTime_duration(interval, start_time, tunit, duration, _RC)
      @assertEqual(expected_duration, duration, 'duration does not match.') 

   end subroutine test_make_NetCDF_DateTime_duration_integer

   @Test
   subroutine test_convert_NetCDF_DateTimeString_to_ESMF_Time()
      character(len=19), parameter:: netcdf_string='2023-01-31 14:04:37'
      type(ESMF_Time) :: etime
      integer :: yy, mm, dd, h, m, s
      integer :: status, rc

      call convert_NetCDF_DateTimeString_to_ESMF_Time(netcdf_string, etime, _RC)
      call ESMF_TimeGet(etime, yy=yy, mm=mm, dd=dd, h=h, m=m, s=s, _RC)
      @assertEqual(2023, yy, 'Incorrect year')
      @assertEqual(01, mm, 'Incorrect month')
      @assertEqual(31, dd, 'Incorrect day')
      @assertEqual(14, h, 'Incorrect hour')
      @assertEqual(04, m, 'Incorrect minute')
      @assertEqual(37, s, 'Incorrect second')

   end subroutine test_convert_NetCDF_DateTimeString_to_ESMF_Time

   @Test
   subroutine test_get_shift_sign()
      character(len=:), allocatable :: preposition
      integer, parameter :: expected = 1

      preposition = 'since'
      @assertEqual(expected, get_shift_sign(preposition))
      preposition = 'before'
      @assertFalse(get_shift_sign(preposition) == expected)
      preposition = ''
      @assertFalse(get_shift_sign(preposition) == expected)
   end subroutine test_get_shift_sign

   @Test
   subroutine test_split_chars()
      character(len=*), parameter :: head = 'head'
      character(len=*), parameter :: tail = 'tail'
      character(len=*), parameter :: delim = '::'
      character(len=:), allocatable :: test_string
      character(len=:), allocatable :: parts(:)

      test_string = head // delim // tail
      parts = split(test_string, delim)
      @assertEqual(2, size(parts), 'Two parts expected.')
      @assertEqual(head, parts(1), 'Part 1 does not match head.')
      @assertEqual(tail, parts(2), 'Part 2 does not match tail.')

      test_string = delim // tail
      parts = split(test_string, delim)
      @assertEqual(tail, parts(2), 'Part 2 does not match tail.')
      @assertEqual(0, len_trim(parts(1)),'Part 1 has nonzero length.')

      test_string = head // delim
      parts = split(test_string, delim)
      @assertEqual(head, parts(1), 'Part 1 does not match head.')
      @assertEqual(0, len_trim(parts(2)),'Part 2 has nonzero length.')

      test_string = head // '  ' // tail
      parts = split(test_string, delim)
      @assertEqual(test_string, parts(1), 'Part 1 does not match test_string.')
      @assertEqual(0, len_trim(parts(2)),'Part 2 has nonzero length.')

      test_string = ''
      parts = split(test_string, delim)
      @assertEqual(0, len_trim(parts(1)),'Part 1 has nonzero length.')
      @assertEqual(0, len_trim(parts(2)),'Part 2 has nonzero length.')

   end subroutine test_split_chars

   @Test
   subroutine test_split_all_iterative()
      integer, parameter :: N = 6
      integer, parameter :: SLEN = 4
      character(len=SLEN), parameter :: chunk(N) = ['mice', 'dogs', 'rats', 'fish', 'deer', 'pigs']
      character(len=:), allocatable :: dlm
      character(len=:), allocatable :: test_string
      character(len=:), allocatable :: parts(:)
      integer :: i

      dlm = ' '
      test_string =  'mice' // dlm // 'dogs' // dlm // 'rats' // dlm // 'fish' // dlm // 'deer' // dlm // 'pigs'

      parts = split_all(test_string, dlm)
      @assertEqual(size(parts), size(chunk), 'Number of parts do not match.')
      do i = 1, size(chunk)
         @assertEqual(chunk(i), parts(i))
      end do

   end subroutine test_split_all_iterative
 
   @Test
   subroutine test_is_valid_netcdf_datetime_string()
      character(len=:), allocatable :: string

      string = '1970-01-01 23:59:59'
      @assertTrue(is_valid_netcdf_datetime_string(string), string // ' is not a valid NetCDF datetime string.')

      string = '1970-01-01  23:59:59'
      @assertFalse(is_valid_netcdf_datetime_string(string), string // ' is not a valid NetCDF datetime string.')

      string = '1970:01-01 23:59:59'
      @assertFalse(is_valid_netcdf_datetime_string(string), string // ' is not a valid NetCDF datetime string.')

      string = '1970-01-01 23-59:59'
      @assertFalse(is_valid_netcdf_datetime_string(string), string // ' is not a valid NetCDF datetime string.')

      string = '1970-01-01T23:59:59'
      @assertFalse(is_valid_netcdf_datetime_string(string), string // ' is not a valid NetCDF datetime string.')

   end subroutine test_is_valid_netcdf_datetime_string

   @Test
   subroutine test_convert_to_integer()
      character(len=:), allocatable :: str
      integer :: expected, actual, status

      expected = 2023
      str = '2023'
      call convert_to_integer(str, actual, rc = status)
      @assertTrue(status == SUCCESS, 'Unsuccessful conversion: ' // str)
      @assertEqual(expected, actual, 'Incorrect conversion: ' // str)

      expected = -2023
      str = '-2023'
      call convert_to_integer(str, actual, rc = status)
      @assertTrue(status == SUCCESS, 'Unsuccessful conversion: ' // str)
      @assertEqual(expected, actual, 'Incorrect conversion: ' // str)

      expected = 0
      str = '0'
      call convert_to_integer(str, actual, rc = status)
      @assertTrue(status == SUCCESS, 'Unsuccessful conversion: ' // str)
      @assertEqual(expected, actual, 'Incorrect conversion: ' // str)

      expected = 0
      str = '0.0'
      call convert_to_integer(str, actual, rc = status)
      @assertTrue(.not. status == SUCCESS, str // ' should not convert.')

   end subroutine test_convert_to_integer

   @Test
   subroutine test_make_ESMF_TimeInterval_real()
      character(len=*), parameter :: units = 'seconds'
      character(len=*), parameter :: iso_string = '2013-08-26T12:34:56'
      real(kind=ESMF_KIND_R8), parameter :: duration = 1800
      type(ESMF_TimeInterval) :: expected_interval
      type(ESMF_Time) :: start_time
      type(ESMF_TimeInterval) :: interval
      integer :: rc, status

      call ESMF_TimeSet(start_time, iso_string, _RC)
      call ESMF_TimeIntervalSet(expected_interval, startTime=start_time, s_r8=duration, _RC)
      call make_ESMF_TimeInterval(duration, units, start_time, interval, _RC)
      @assertTrue(expected_interval == interval, 'ESMF_TimeInterval variables do not match.')

   end subroutine test_make_ESMF_TimeInterval_real

   @Test
   subroutine test_make_NetCDF_DateTime_duration_real()
      character(len=*), parameter :: tunit = 'seconds'
      character(len=*), parameter :: iso_string = '2013-08-26T12:34:56'
      type(ESMF_TimeInterval) :: interval
      type(ESMF_Time) :: start_time
      real(kind=ESMF_KIND_R8), parameter :: expected_duration = 1800
      real(kind=ESMF_KIND_R8) :: duration
      integer :: status, rc

      call ESMF_TimeSet(start_time, iso_string, _RC)
      call ESMF_TimeIntervalSet(interval, startTime=start_time, s_r8=expected_duration, _RC)

      call make_NetCDF_DateTime_duration(interval, start_time, tunit, duration, _RC)
      @assertEqual(expected_duration, duration, 'int_time does not match.') 

   end subroutine test_make_NetCDF_DateTime_duration_real

   @Test
   subroutine test_is_digit_string()
      character(len=:), allocatable :: test_string
      
      test_string = '1'
      @assertTrue(is_digit_string(test_string), '"' // test_string // '" is a digit string.')
      test_string = '9362754810'
      @assertTrue(is_digit_string(test_string), '"' // test_string // '" is a digit string.')
      test_string = '125     '
      @assertTrue(is_digit_string(test_string), '"' // test_string // '" is a digit string.')
      test_string = 'ADFG'
      @assertTrue(.not. is_digit_string(test_string), '"' // test_string // '" is not a digit string.')
      test_string = '1ADFG'
      @assertTrue(.not. is_digit_string(test_string), '"' // test_string // '" is not a digit string.')
      test_string = '1213A'
      @assertTrue(.not. is_digit_string(test_string), '"' // test_string // '" is not a digit string.')
      test_string = ' 1213'
      @assertTrue(.not. is_digit_string(test_string), '"' // test_string // '" is not a digit string.')
      test_string = '   '
      @assertTrue(.not. is_digit_string(test_string), '"' // test_string // '" is not a digit string.')
      test_string = '%^*'
      @assertTrue(.not. is_digit_string(test_string), '"' // test_string // '" is not a digit string.')
      test_string = '9%^*7'
      @assertTrue(.not. is_digit_string(test_string), '"' // test_string // '" is not a digit string.')
      test_string = ''
      @assertTrue(.not. is_digit_string(test_string), '"' // test_string // '" is not a digit string.')
   end subroutine test_is_digit_string

   @Test
   subroutine test_convert_to_real()
      character(len=:), allocatable :: str
      real(kind=ESMF_KIND_R8) :: expected, actual
      real(kind=ESMF_KIND_R8), parameter :: RELATIVE_TOLERANCE = 1D-08
      real(kind=ESMF_KIND_R8) :: tolerance
      integer :: status

      expected = 6.015625
      tolerance = expected * RELATIVE_TOLERANCE
      str = '6.015625'
      call convert_to_real(str, actual, rc = status)
      @assertEqual(SUCCESS, status, 'Unsuccessful conversion: ' // str)
      @assertEqual(expected, actual, tolerance, 'Incorrect conversion: ' // str)

      expected = -6.015625
      tolerance = expected * RELATIVE_TOLERANCE
      str = '-6.015625'
      call convert_to_real(str, actual, rc = status)
      @assertEqual(SUCCESS, status, 'Unsuccessful conversion: ' // str)
      @assertEqual(expected, actual, tolerance, 'Incorrect conversion: ' // str)

      expected = 2023
      tolerance = expected * RELATIVE_TOLERANCE
      str = '2023'
      call convert_to_real(str, actual, rc = status)
      @assertEqual(SUCCESS, status, 'Unsuccessful conversion: ' // str)
      @assertEqual(expected, actual, tolerance, 'Incorrect conversion: ' // str)

      expected = 0.015625
      tolerance = expected * RELATIVE_TOLERANCE
      str = '0.015625'
      call convert_to_real(str, actual, rc = status)
      @assertEqual(SUCCESS, status, 'Unsuccessful conversion: ' // str)
      @assertEqual(expected, actual, tolerance, 'Incorrect conversion: ' // str)

      expected = 0.015625
      tolerance = expected * RELATIVE_TOLERANCE
      str = '.015625'
      call convert_to_real(str, actual, rc = status)
      @assertEqual(SUCCESS, status, 'Unsuccessful conversion: ' // str)
      @assertEqual(expected, actual, tolerance, 'Incorrect conversion: ' // str)

      expected = 6.015625
      tolerance = expected * RELATIVE_TOLERANCE
      str = 'asdf6.015625'
      call convert_to_real(str, actual, rc = status)
      @assertTrue(.not. status == SUCCESS, str // ' should not convert.')

   end subroutine test_convert_to_real

   @Test
   subroutine test_ESMF_Times_Equal()
      integer :: yy = 1957
      integer :: mm = 10
      integer :: dd = 19
      integer :: h = 18
      integer :: m = 37
      integer :: s = 53
      type(ESMF_Time) :: timea, timeb
      integer :: status

      call ESMF_TimeSet(timea, yy=yy, mm=mm, dd=dd, h=h, m=m, s=s, rc = status)
      @assertTrue(status == SUCCESS, 'Failed to create timea')
      call ESMF_TimeSet(timeb, yy=yy, mm=mm, dd=dd, h=h, m=m, s=s, rc = status)
      @assertTrue(status == SUCCESS, 'Failed to create timeb')
      @assertTrue(timea == timeb, 'ESMF_Time values are not equal.')
      @assertTrue(ESMF_Times_Equal(timea, timeb), 'ESMF_Time values do not match.')

   end subroutine test_ESMF_Times_Equal

   @Test
   subroutine test_make_datetime_string()
      integer, parameter :: YY = 1999
      integer, parameter :: MM = 12
      integer, parameter :: DD = 31
      integer, parameter :: H = 23
      integer, parameter :: M = 59
      integer, parameter :: S = 59

      character(len=*), parameter :: EXPECTED_DATETIME_STRING = '1999-12-31 23:59:59'
      integer, parameter :: EXPECTED_LENGTH = len(EXPECTED_DATETIME_STRING)

      character(len=:), allocatable :: actual_datetime_string

      actual_datetime_string = make_datetime_string(yy, mm, dd, h, m, s)
      @assertEqual(EXPECTED_LENGTH, len_trim(actual_datetime_string), 'Incorrect length for datetime string')
      @assertEqual(EXPECTED_DATETIME_STRING, trim(actual_datetime_string), 'Datetime strings do not match.')
      
   end subroutine test_make_datetime_string

   @Test
   subroutine test_make_units_string()
      integer, parameter :: YY = 1999
      integer, parameter :: MM = 12
      integer, parameter :: DD = 31
      integer, parameter :: H = 23
      integer, parameter :: M = 59
      integer, parameter :: S = 59
      
      character(len=*), parameter :: SPACE = ' '
      character(len=*), parameter :: EXPECTED_UNITS = 'seconds'
      character(len=*), parameter :: EXPECTED_PREPOSITION = 'since'
      character(len=*), parameter :: EXPECTED_UNITS_STRING = EXPECTED_UNITS // &
         SPACE // EXPECTED_PREPOSITION // SPACE // '1999-12-31 23:59:59'
      integer, parameter :: EXPECTED_LENGTH = len(EXPECTED_UNITS_STRING)
      
      character(len=:), allocatable :: actual_units_string

      actual_units_string = make_units_string(EXPECTED_UNITS, EXPECTED_PREPOSITION, YY, MM, DD, H, M, S)
      @assertEqual(EXPECTED_LENGTH, len_trim(actual_units_string), "Incorrect length for actual_units_string")
      @assertEqual(EXPECTED_UNITS_STRING, actual_units_string, "Units_string's do not match.")

   end subroutine test_make_units_string

end module test_MAPL_NetCDF_private
