#include "MAPL_Exceptions.h"
#include "MAPL_ErrLog.h"

module Test_MAPL_Resource
   use MAPL_ResourceMod
   use ESMF
   use pfunit
   use MAPL_ExceptionHandling
   use, intrinsic :: iso_fortran_env, only: REAL32, REAL64, int32, int64

   implicit none

   integer, parameter :: PRINT_ALL = 1
   integer, parameter :: PRINT_DIFFERENT = 0
   integer, parameter :: PRINT_NOTHING = -1
   character(len=*), parameter :: EMPTY_STRING = ''
   character(len=*), parameter :: OUTPUT_BASE  = ' Resource Parameter: '
   character(len=*), parameter :: CHAR__PREFIX = 'Character'
   character(len=*), parameter :: INT4__PREFIX = 'Integer*4'
   character(len=*), parameter :: INT8__PREFIX = 'Integer*8'
   character(len=*), parameter :: REAL4_PREFIX = 'Real*4'
   character(len=*), parameter :: REAL8_PREFIX = 'Real*8'
   character(len=*), parameter :: LOGIC_PREFIX = 'Logical'
   character(len=*), parameter :: DEFAU_SUFFIX = ', (default value)'

   type :: varstring
      private
      character(len=:), allocatable :: s
   contains
      procedure, public, pass(this) :: get_character
      procedure, public, pass(this) :: length
   end type varstring

   interface varstring
      module procedure :: construct_varstring
   end interface varstring
   
contains

   integer function find_longest_length(a) result(length)
      class(varstring), intent(in) :: a(:)
      integer :: i

      length = 0
      do i= 1, size(a)
         length = max(length, a(i) % length()
      end do

   end function find_longest_length

   function make_character_array(va) result(ca)
      class(varstring), intent(in) :: va(:)
      character(len=:), allocatable :: ca(:)
      integer :: i

      length = find_longest_length(va)
      allocate(character(len=find_longest_length(va)) :: ca(size(va))

      do i = 1, size(ca)
         ca(i) = va(i) % get_character()
      end do

   end function make_character_array

   function construct_varstring(s) result(r)
      character(len=*), intent(in) :: s
      type(varstring) :: r

      r % s = s

   end function construct_varstring

   function get_character(this) result(s)
      class(varstring), intent(in) :: this
      character(len=:), allocatable :: s

      s = this % s
   end function get_character

   integer function length(this)
      class(varstring), intent(in) :: this

      length = len(this % get_character())
   end function length

   @Test
   subroutine Test_MAPL_GetResource_scalar_int4()
      type(ESMF_Config) :: config
      integer :: status
      integer(kind=int32) :: expected, actual
      character(len=*), parameter :: LABEL = 'label'
      character(len=*), parameter :: VAL = '1'
      logical :: value_is_set
      character(len=MAX_LINE_LENGTH) :: output_string

      expected = 1
      config = ESMF_ConfigCreate(rc = status)
      @assertEqual(0, status, 'Failed to create ESMF_Config')
      call ESMF_ConfigSetAttribute(config, PRINT_ALL, label = 'PRINTRC:', rc = status)
      @assertEqual(0, status, 'Failed to set PRINTRC')
      call ESMF_ConfigSetAttribute(config, VAL, label = LABEL, rc = status)
      @assertEqual(0, status, 'Failed to set attribute')
      call MAPL_GetResource_config_scalar(config, actual, label = LABEL, value_is_set = value_is_set, iunit=output_string, rc = status)
      @assertEqual(0, status, 'Failed to get resource')
      @assertEqual(expected, actual, 'actual does not match expected.')
   end subroutine Test_MAPL_GetResource_scalar_int4

   @Test
   subroutine Test_MAPL_GetResource_scalar_int8()
      type(ESMF_Config) :: config
      integer :: status
      integer(kind=int64) :: expected, actual
      character(len=*), parameter :: LABEL = 'label'
      character(len=*), parameter :: VAL = '1'
      logical :: value_is_set

      config = ESMF_ConfigCreate(rc = status)
      @assertEqual(0, status, 'Failed to create ESMF_Config')
      call ESMF_ConfigSetAttribute(config, PRINT_ALL, label = 'PRINTRC:', rc = status)
      @assertEqual(0, status, 'Failed to set PRINTRC')
      call ESMF_ConfigSetAttribute(config, VAL, label = LABEL, rc = status)
      @assertEqual(0, status, 'Failed to set attribute')
      expected = 1
      call MAPL_GetResource_config_scalar(config, actual, label = LABEL, value_is_set = value_is_set, rc = status)
      @assertEqual(0, status, 'Failed to get resource')
      @assertEqual(expected, actual, 'actual does not match expected.')
      
   end subroutine Test_MAPL_GetResource_scalar_int8

   @Test
   subroutine Test_MAPL_GetResource_scalar_real4()
      type(ESMF_Config) :: config
      integer :: status
      real(kind=real32) :: expected, actual
      character(len=*), parameter :: LABEL = 'label'
      character(len=*), parameter :: VAL = '1.0'
      logical :: value_is_set

      config = ESMF_ConfigCreate(rc = status)
      @assertEqual(0, status, 'Failed to create ESMF_Config')
      call ESMF_ConfigSetAttribute(config, PRINT_ALL, label = 'PRINTRC:', rc = status)
      @assertEqual(0, status, 'Failed to set PRINTRC')
      call ESMF_ConfigSetAttribute(config, VAL, label = LABEL, rc = status)
      @assertEqual(0, status, 'Failed to set attribute')
      expected = 1.0
      call MAPL_GetResource_config_scalar(config, actual, label = LABEL, value_is_set = value_is_set, rc = status)
      @assertEqual(0, status, 'Failed to get resource')
      @assertEqual(expected, actual, 'actual does not match expected.')
      
   end subroutine Test_MAPL_GetResource_scalar_real4

   @Test
   subroutine Test_MAPL_GetResource_scalar_real8()
      type(ESMF_Config) :: config
      integer :: status
      real(kind=real64) :: expected, actual
      character(len=*), parameter :: LABEL = 'label'
      character(len=*), parameter :: VAL = '1.0'
      logical :: value_is_set

      config = ESMF_ConfigCreate(rc = status)
      @assertEqual(0, status, 'Failed to create ESMF_Config')
      call ESMF_ConfigSetAttribute(config, PRINT_ALL, label = 'PRINTRC:', rc = status)
      @assertEqual(0, status, 'Failed to set PRINTRC')
      call ESMF_ConfigSetAttribute(config, VAL, label = LABEL, rc = status)
      @assertEqual(0, status, 'Failed to set attribute')
      expected = 1.0
      call MAPL_GetResource_config_scalar(config, actual, label = LABEL, value_is_set = value_is_set, rc = status)
      @assertEqual(0, status, 'Failed to get resource')
      @assertEqual(expected, actual, 'actual does not match expected.')
      
   end subroutine Test_MAPL_GetResource_scalar_real8

   @Test
   subroutine Test_MAPL_GetResource_scalar_character()
      type(ESMF_Config) :: config
      integer :: status
      character(ESMF_MAXSTR) :: expected, actual
      character(len=*), parameter :: LABEL = 'label'
      character(len=*), parameter :: VAL = 'value'
      character(len=MAX_LINE_LENGTH) :: output_string
      logical :: value_is_set

      config = ESMF_ConfigCreate(rc = status)
      @assertEqual(0, status, 'Failed to create ESMF_Config')
      call ESMF_ConfigSetAttribute(config, PRINT_ALL, label = 'PRINTRC:', rc = status)
      @assertEqual(0, status, 'Failed to set PRINTRC')
      call ESMF_ConfigSetAttribute(config, VAL, label = LABEL, rc = status)
      @assertEqual(0, status, 'Failed to set attribute')
      expected = VAL
      call MAPL_GetResource_config_scalar(config, actual, label = LABEL, value_is_set = value_is_set, iunit = output_string, rc = status)
      @assertEqual(0, status, 'Failed to get resource')
      @assertEqual(expected, actual, 'actual does not match expected.')
      @assertTrue(len_trim(output_string) > len(VAL), 'output_string should be longer than VAL')
      @assertTrue(len_trim(output_string) <= MAX_LINE_LENGTH, 'output_string is too long.')

   end subroutine Test_MAPL_GetResource_scalar_character

   @Test
   subroutine Test_MAPL_GetResource_scalar_logical()
      type(ESMF_Config) :: config
      integer :: status
      logical :: expected, actual, match
      character(len=*), parameter :: LABEL = 'label'
      character(len=*), parameter :: VAL = '.T.'
      logical :: value_is_set

      config = ESMF_ConfigCreate(rc = status)
      @assertEqual(0, status, 'Failed to create ESMF_Config')
      call ESMF_ConfigSetAttribute(config, PRINT_ALL, label = 'PRINTRC:', rc = status)
      @assertEqual(0, status, 'Failed to set PRINTRC')
      call ESMF_ConfigSetAttribute(config, VAL, label = LABEL, rc = status)
      @assertEqual(0, status, 'Failed to set attribute')
      expected = .TRUE.
      call MAPL_GetResource_config_scalar(config, actual, label = LABEL, value_is_set = value_is_set, rc = status)
      @assertEqual(0, status, 'Failed to get resource')
      match = expected .eqv. actual 
      @assertTrue(match, 'actual does not match expected.')

   end subroutine Test_MAPL_GetResource_scalar_logical

   @Test
   subroutine Test_MAPL_GetResource_array_int4()
      type(ESMF_Config) :: config
      integer :: status
      integer(kind=int32) :: expected(4), actual(4)
      character(len=*), parameter :: LABEL = 'label'
      character(len=*), parameter :: VAL = '1 2 3 4'
      logical :: value_is_set
      character(len=MAX_LINE_LENGTH) :: output_string

      expected = [1, 2, 3, 4]
      config = ESMF_ConfigCreate(rc = status)
      @assertEqual(0, status, 'Failed to create ESMF_Config')
      call ESMF_ConfigSetAttribute(config, PRINT_ALL, label = 'PRINTRC:', rc = status)
      @assertEqual(0, status, 'Failed to set PRINTRC')
      call ESMF_ConfigSetAttribute(config, VAL, label = LABEL, rc = status)
      @assertEqual(0, status, 'Failed to set attribute')
      call MAPL_GetResource_config_array(config, actual, label = LABEL, value_is_set = value_is_set, iunit=output_string, rc = status)
      @assertEqual(0, status, 'Failed to get resource')
      @assertEqual(expected, actual, 'actual does not match expected.')

   end subroutine Test_MAPL_GetResource_array_int4

   @Test
   subroutine Test_MAPL_GetResource_array_int8()
      type(ESMF_Config) :: config
      integer :: status
      integer(kind=int64) :: expected(4), actual(4)
      character(len=*), parameter :: LABEL = 'label'
      character(len=*), parameter :: VAL = '1 2 3 4'
      logical :: value_is_set
      character(len=MAX_LINE_LENGTH) :: output_string

      expected = [1, 2, 3, 4]
      config = ESMF_ConfigCreate(rc = status)
      @assertEqual(0, status, 'Failed to create ESMF_Config')
      call ESMF_ConfigSetAttribute(config, PRINT_ALL, label = 'PRINTRC:', rc = status)
      @assertEqual(0, status, 'Failed to set PRINTRC')
      call ESMF_ConfigSetAttribute(config, VAL, label = LABEL, rc = status)
      @assertEqual(0, status, 'Failed to set attribute')
      call MAPL_GetResource_config_array(config, actual, label = LABEL, value_is_set = value_is_set, iunit=output_string, rc = status)
      @assertEqual(0, status, 'Failed to get resource')
      @assertEqual(expected, actual, 'actual does not match expected.')

   end subroutine Test_MAPL_GetResource_array_int8

   @Test
   subroutine Test_MAPL_GetResource_array_real4()
      type(ESMF_Config) :: config
      integer :: status
      real(kind=real32) :: expected(4), actual(4)
      character(len=*), parameter :: LABEL = 'label'
      character(len=*), parameter :: VAL = '1.0 2.0 3.0 4.0'
      logical :: value_is_set
      character(len=MAX_LINE_LENGTH) :: output_string

      expected = [1.0, 2.0, 3.0, 4.0]
      config = ESMF_ConfigCreate(rc = status)
      @assertEqual(0, status, 'Failed to create ESMF_Config')
      call ESMF_ConfigSetAttribute(config, PRINT_ALL, label = 'PRINTRC:', rc = status)
      @assertEqual(0, status, 'Failed to set PRINTRC')
      call ESMF_ConfigSetAttribute(config, VAL, label = LABEL, rc = status)
      @assertEqual(0, status, 'Failed to set attribute')
      call MAPL_GetResource_config_array(config, actual, label = LABEL, value_is_set = value_is_set, iunit=output_string, rc = status)
      @assertEqual(0, status, 'Failed to get resource')
      @assertEqual(expected, actual, 'actual does not match expected.')

   end subroutine Test_MAPL_GetResource_array_real4

   @Test
   subroutine Test_MAPL_GetResource_array_real8()
      type(ESMF_Config) :: config
      integer :: status
      real(kind=real64) :: expected(4), actual(4)
      character(len=*), parameter :: LABEL = 'label'
      character(len=*), parameter :: VAL = '1.0 2.0 3.0 4.0'
      logical :: value_is_set
      character(len=MAX_LINE_LENGTH) :: output_string

      expected = [1.0, 2.0, 3.0, 4.0]
      config = ESMF_ConfigCreate(rc = status)
      @assertEqual(0, status, 'Failed to create ESMF_Config')
      call ESMF_ConfigSetAttribute(config, PRINT_ALL, label = 'PRINTRC:', rc = status)
      @assertEqual(0, status, 'Failed to set PRINTRC')
      call ESMF_ConfigSetAttribute(config, VAL, label = LABEL, rc = status)
      @assertEqual(0, status, 'Failed to set attribute')
      call MAPL_GetResource_config_array(config, actual, label = LABEL, value_is_set = value_is_set, iunit=output_string, rc = status)
      @assertEqual(0, status, 'Failed to get resource')
      @assertEqual(expected, actual, 'actual does not match expected.')

   end subroutine Test_MAPL_GetResource_array_real8

   @Test
   subroutine Test_MAPL_GetResource_array_character()
      type(ESMF_Config) :: config
      integer :: status
      character(len=ESMF_MAXSTR) :: expected(4), actual(4)
      character(len=*), parameter :: LABEL = 'label'
      character(len=*), parameter :: VAL = 'bop fop hop mop' 
      logical :: value_is_set
      character(len=MAX_LINE_LENGTH) :: output_string

      expected = ['bop', 'fop', 'hop', 'mop']
      config = ESMF_ConfigCreate(rc = status)
      @assertEqual(0, status, 'Failed to create ESMF_Config')
      call ESMF_ConfigSetAttribute(config, PRINT_ALL, label = 'PRINTRC:', rc = status)
      @assertEqual(0, status, 'Failed to set PRINTRC')
      call ESMF_ConfigSetAttribute(config, VAL, label = LABEL, rc = status)
      @assertEqual(0, status, 'Failed to set attribute')
      call MAPL_GetResource_config_array(config, actual, label = LABEL, value_is_set = value_is_set, iunit=output_string, rc = status)
      @assertEqual(0, status, 'Failed to get resource')
      @assertEqual(expected, actual, 'actual does not match expected.')

   end subroutine Test_MAPL_GetResource_array_character

   @Test
   subroutine Test_MAPL_GetResource_array_logical()
      type(ESMF_Config) :: config
      integer :: status
      logical :: expected(4), actual(4), match
      character(len=*), parameter :: LABEL = 'label'
      character(len=*), parameter :: VAL = '.T. .F. .F. .T.'
      logical :: value_is_set
      character(len=MAX_LINE_LENGTH) :: output_string

      expected = [.TRUE., .FALSE., .FALSE., .TRUE.]
      config = ESMF_ConfigCreate(rc = status)
      @assertEqual(0, status, 'Failed to create ESMF_Config')
      call ESMF_ConfigSetAttribute(config, PRINT_ALL, label = 'PRINTRC:', rc = status)
      @assertEqual(0, status, 'Failed to set PRINTRC')
      call ESMF_ConfigSetAttribute(config, VAL, label = LABEL, rc = status)
      @assertEqual(0, status, 'Failed to set attribute')
      call MAPL_GetResource_config_array(config, actual, label = LABEL, value_is_set = value_is_set, iunit=output_string, rc = status)
      @assertEqual(0, status, 'Failed to get resource')
      match = all(expected .eqv. actual)
      @assertTrue(match, 'actual does not match expected.')

   end subroutine Test_MAPL_GetResource_array_logical

   @After
   subroutine tear_down()

   end subroutine tear_down

   @Before
   subroutine set_up()

   end subroutine set_up

! split string at the first delimiter (d_) into next and remainder; return both
! if d is present, delimiter is d, otherwise delimiter is " "
! if delimiter is empty or delimiter length > string length, return two empty strings
! if delimiter is not found in string, next=string and remainder is empty
! Otherwise next is the string before the delimiter, and remainder is the string after the delimiter (if any)
   subroutine split(string, next, remainder, d, merge_delimiters)
      character(len=*), intent(in) :: string
      character(len=len(string)), intent(out) :: next, remainder
      character(len=*), optional, intent(in) :: d
      logical, optional, intent(in) :: merge_delimiters
      character(len=:), allocatable :: d_
      logical :: merge_delimiters_
      integer :: len_d, len_string, i

      d_ = ' '
      next = EMPTY_STRING
      remainder = EMPTY_STRING
      if(present(d)) d_ = d
      len_d = len(d_)
      len_string = len(string)
      if((len_d > 0) .and. (len_d <= len_string)) then
         i = index(string, d_)
         if(i == 0) then
            next = string
         else
            if(i < (len_string - len_d + 1)) remainder = string((i + len_d):len(string))
            next = string(1:(i-1))
         end if
      end if
   end subroutine split

   function split_all(string, d, merge_delimiters)
      character(len=*), intent(in) :: string
      character(len=*), optional, intent(in) :: d
      logical, optional, intent(in) :: merge_delimiters
      character(len=:), allocatable :: d_
      type(varstring), allocatable :: p(:)
      character(len=len(string)) :: next, remainder
      character(len=:), allocatable :: parts(:)
      integer :: n
      
      if(present(d) then
         d_ = d
      else
         d_ = ' '
      end if

      allocate(p(0))

      remainder = string
      do while(len_trim(remainder) > 0)
         call split(string, next, remainder)
         if(len_trim(next) > 0) p = [p, varstring(next)]
      end do
      
      parts = make_character_array(p)
      
   end function split_all

   function starts(substring, string) result(lval)
      logical :: lval
      character(len=*), intent(in) :: string, substring

      lval = (index(trim(string), trim(substring)) == 1)

   end function starts

   function ends(substring, string) result(lval)
      logical :: lval
      character(len=*), intent(in) :: string, substring
      integer :: ls, lss, start

      lval = (len_trim(substring) == 0)
      if(.not. lval) then
         lss = len_trim(substring)
         ls = len_trim(string)
         start = ls - lss + 1
         lval = (index(trim(string), trim(substring)) == start)
      end if

   end function ends

end module Test_MAPL_Resource
