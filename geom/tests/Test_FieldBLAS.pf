#include "MAPL_Generic.h"

module Test_FieldBLAS

   use mapl3g_FieldBLAS
   use ESMF
   use funit
   use MAPL_ExceptionHandling

   implicit none

   interface mk_field
      module procedure mk_field_r4
      module procedure mk_field_r8
   end interface mk_field

   interface initialize_array
      module procedure initialize_array_R4
      module procedure initialize_array_R8
   end interface initialize_array

   interface difference_string
      module procedure difference_scalar
      module procedure difference_array
   end interface difference_string
   
   integer :: i
   type(ESMF_Index_Flag), parameter :: INDEX_FLAG_DEFAULT = ESMF_INDEX_DELOCAL
   integer, parameter :: REG_DECOMP_DEFAULT(*) = [2, 2]
   integer, parameter :: MAX_INDEX_DEFAULT(*) = [4, 4]
   integer, parameter :: MIN_INDEX_DEFAULT(*) = [1, 1]
   integer, parameter :: DIMR4_DEFAULT(*) = [4, 4]
   integer, parameter :: DIMR8_DEFAULT(*) = [4, 4]
   integer, parameter :: SIZE_R4 = 16
   integer, parameter :: SIZE_R8 = 16

   real(kind=ESMF_KIND_R4), parameter :: R4_ARRAY_DEFAULT(*,*) = reshape([(i, i = 1, SIZE_R4)], DIMR4_DEFAULT)
   real(kind=ESMF_KIND_R8), parameter :: R8_ARRAY_DEFAULT(*,*) = reshape([(i, i = 1, SIZE_R8)], DIMR8_DEFAULT) 
   
   type(ESMF_Field) :: XR4
   type(ESMF_Field) :: XR8
   type(ESMF_Field) :: YR4
   type(ESMF_Field) :: YR8
   
contains

   ! MAKE GRID FOR FIELDS
   function mk_grid(regDecomp, minIndex, maxIndex, indexflag, grid_name, rc) result(grid)
      integer, dimension(:), intent(in) :: regDecomp
      integer, dimension(:), intent(in) :: minIndex
      integer, dimension(:), intent(in) :: maxIndex
      type(ESMF_Index_Flag), intent(in) :: indexflag
      character(len=*), intent(in) :: grid_name
      integer, optional, intent(out) :: rc

      type(ESMF_Grid) :: grid

      integer :: status

      grid = ESMF_GridCreateNoPeriDim(regDecomp = regDecomp, maxIndex = maxIndex, minIndex = minIndex, indexflag = indexflag, name = grid_name, _RC)

      _RETURN(_SUCCESS)
   end function mk_grid
   
   ! MAKE FIELD FOR REAL(KIND=ESMF_KIND_R4)
   function mk_field_r4(farray, regDecomp, minIndex, maxIndex, indexflag, name, rc) result(field)
      real(kind=ESMF_KIND_R4), dimension(:,:), target, intent(in) :: farray
      integer, dimension(:), intent(in) :: regDecomp
      integer, dimension(:), intent(in) :: minIndex
      integer, dimension(:), intent(in) :: maxIndex
      type(ESMF_Index_Flag), intent(in) :: indexflag
      character(len=*), intent(in) :: name
      integer, optional, intent(out) :: rc

      type(ESMF_Field) :: field
      real(kind=ESMF_KIND_R4), dimension(:,:), pointer :: ptr

      integer :: status

      field = mk_field_common(tk = ESMF_TYPEKIND_R4, regDecomp=regDecomp, minIndex=minIndex, maxIndex=maxIndex, indexflag = indexflag, name = name, _RC)
      call ESMF_FieldGet(field, farrayPtr = ptr, _RC)
      ptr => farray

      _RETURN(_SUCCESS)
   end function mk_field_r4

   ! MAKE FIELD FOR REAL(KIND=ESMF_KIND_R8)
   function mk_field_r8(farray, regDecomp, minIndex, maxIndex, indexflag, name, rc) result(field)
      real(kind=ESMF_KIND_R8), dimension(:,:), target, intent(in) :: farray
      integer, dimension(:), intent(in) :: regDecomp
      integer, dimension(:), intent(in) :: minIndex
      integer, dimension(:), intent(in) :: maxIndex
      type(ESMF_Index_Flag), intent(in) :: indexflag
      character(len=*), intent(in) :: name
      integer, optional, intent(out) :: rc

      type(ESMF_Field) :: field
      real(kind=ESMF_KIND_R8), dimension(:,:), pointer :: ptr

      integer :: status

      field = mk_field_common(tk = ESMF_TYPEKIND_R8, regDecomp=regDecomp, minIndex=minIndex, maxIndex=maxIndex, indexflag = indexflag, name = name, _RC)
      call ESMF_FieldGet(field, farrayPtr = ptr, _RC)
      ptr => farray

      _RETURN(_SUCCESS)
   end function mk_field_r8

   function mk_field_common(tk, regDecomp, minIndex, maxIndex, indexflag, name, rc) result(field)
      type(ESMF_TypeKind_Flag), intent(in) :: tk
      integer, dimension(:), intent(in) :: regDecomp
      integer, dimension(:), intent(in) :: minIndex
      integer, dimension(:), intent(in) :: maxIndex
      type(ESMF_Index_Flag), intent(in) :: indexflag
      character(len=*), intent(in) :: name
      integer, optional, intent(out) :: rc
      character(len=*), parameter :: GRID_SUFFIX = '_grid'
      character(len=*), parameter :: FIELD_SUFFIX = '_field'
      
      type(ESMF_Field) :: field
      type(ESMF_Grid) :: grid
      integer :: status

      grid = mk_grid(regDecomp=regDecomp, minIndex=minIndex, maxIndex=maxIndex, indexflag = indexflag, grid_name = name // GRID_SUFFIX, _RC)
      field = ESMF_FieldCreate(grid, typekind = tk, name = name // FIELD_SUFFIX, _RC)

      _RETURN(_SUCCESS)
   end function mk_field_common

   @Before
   subroutine set_up_data()
      implicit none

      integer :: status, rc

      real(kind=ESMF_KIND_R4), parameter :: ADD_R4 = 100.0
      real(kind=ESMF_KIND_R8), parameter :: ADD_R8 = 100.0
      real(kind=ESMF_KIND_R4), allocatable :: y4array(:,:)
      real(kind=ESMF_KIND_R8), allocatable :: y8array(:,:)

      allocate(y4array, source=R4_ARRAY_DEFAULT)
      allocate(y8array, source=R8_ARRAY_DEFAULT)
      y4array = y4array + ADD_R4
      y8array = y8array + ADD_R8
      XR4 = mk_field(R4_ARRAY_DEFAULT, regDecomp=REG_DECOMP_DEFAULT, minIndex=MIN_INDEX_DEFAULT, maxIndex=MAX_INDEX_DEFAULT, &
         indexflag=INDEX_FLAG_DEFAULT, name = 'XR4', _RC)
      YR4 = mk_field(y4array, regDecomp=REG_DECOMP_DEFAULT, minIndex=MIN_INDEX_DEFAULT, maxIndex=MAX_INDEX_DEFAULT, &
         indexflag=INDEX_FLAG_DEFAULT, name = 'YR4', _RC)
      XR8 = mk_field(R8_ARRAY_DEFAULT, regDecomp=REG_DECOMP_DEFAULT, minIndex=MIN_INDEX_DEFAULT, maxIndex=MAX_INDEX_DEFAULT, &
         indexflag=INDEX_FLAG_DEFAULT, name = 'XR8', _RC)
      YR8 = mk_field(y8array, regDecomp=REG_DECOMP_DEFAULT, minIndex=MIN_INDEX_DEFAULT, maxIndex=MAX_INDEX_DEFAULT, &
         indexflag=INDEX_FLAG_DEFAULT, name = 'YR8', _RC)

   end subroutine set_up_data

   @Test
   ! Basic test of FieldCOPY subroutine (REAL32)
   subroutine test_FieldCOPY_R4()
      type(ESMF_Field) :: x
      type(ESMF_Field) :: y
      real(kind=ESMF_KIND_R4), dimension(:,:), pointer :: x_ptr
      real(kind=ESMF_KIND_R4), dimension(:,:), pointer :: y_ptr
      integer :: status, rc
      
      x = XR4
      y = YR4
      call FieldCOPY(x, y, _RC)
      call ESMF_FieldGet(x, farrayPtr = x_ptr, _RC)
      call ESMF_FieldGet(y, farrayPtr = y_ptr, _RC)
      @assertEqual(x_ptr, y_ptr)

   end subroutine test_FieldCOPY_R4

   @Test
   ! Basic test of FieldCOPY subroutine (REAL64)
   subroutine test_FieldCOPY_R8()
      type(ESMF_Field) :: x
      type(ESMF_Field) :: y
      real(kind=ESMF_KIND_R8), dimension(:,:), pointer :: x_ptr
      real(kind=ESMF_KIND_R8), dimension(:,:), pointer :: y_ptr
      integer :: status, rc
      
      x = XR8 
      y = YR8
      call FieldCOPY(x, y, _RC)
      call ESMF_FieldGet(x, farrayPtr = x_ptr, _RC)
      call ESMF_FieldGet(y, farrayPtr = y_ptr, _RC)
      @assertEqual(x_ptr, y_ptr)

   end subroutine test_FieldCOPY_R8

   @Test
   ! Basic test of FieldCOPY subroutine (REAL32 -> REAL64)
   subroutine test_FieldCOPY_R4R8()
      type(ESMF_Field) :: x
      type(ESMF_Field) :: y
      real(kind=ESMF_KIND_R4), dimension(:,:), pointer :: x_ptr
      real(kind=ESMF_KIND_R8), dimension(:,:), pointer :: y_ptr
      integer :: status, rc
      
      x = XR4 
      y = YR8
      call FieldCOPY(x, y, _RC)
      call ESMF_FieldGet(x, farrayPtr = x_ptr, _RC)
      call ESMF_FieldGet(y, farrayPtr = y_ptr, _RC)
      @assertEqual(x_ptr, y_ptr)

   end subroutine test_FieldCOPY_R4R8

   @Test
   ! Basic test of FieldCOPY subroutine (REAL64 -> REAL32)
   subroutine test_FieldCOPY_R8R4()
      type(ESMF_Field) :: x
      type(ESMF_Field) :: y
      real(kind=ESMF_KIND_R8), dimension(:,:), pointer :: x_ptr
      real(kind=ESMF_KIND_R4), dimension(:,:), pointer :: y_ptr
      integer :: status, rc
      
      x = XR8
      y = YR4
      call FieldCOPY(x, y, _RC)
      call ESMF_FieldGet(x, farrayPtr = x_ptr, _RC)
      call ESMF_FieldGet(y, farrayPtr = y_ptr, _RC)
      @assertTrue(all(are_almost_equal(x_ptr, y_ptr)), 'Values differ above threshold.')

   end subroutine test_FieldCOPY_R8R4

   @Test
   ! Basic test of FieldSCAL subroutine (REAL32)
   subroutine test_FieldSCAL_R4()
      real(kind=ESMF_KIND_R4), parameter :: a = 2.0
      type(ESMF_Field) :: x
      real(kind=ESMF_KIND_R4), dimension(:,:), allocatable :: x_array
      real(kind=ESMF_KIND_R4), dimension(:,:), pointer :: x_ptr
      integer :: status, rc

      x = XR4
      call ESMF_FieldGet(x, farrayPtr = x_ptr, _RC)
      x_array = x_ptr
      call FieldSCAL(a, x, _RC)
      call ESMF_FieldGet(x, farrayPtr = x_ptr, _RC)
      @assertEqual(x_ptr, a*x_array)

   end subroutine test_FieldSCAL_R4

   @Test
   ! Basic test of FieldSCAL subroutine (REAL64)
   subroutine test_FieldSCAL_R8()
      real(kind=ESMF_KIND_R8), parameter :: a = 2.0
      type(ESMF_Field) :: x
      real(kind=ESMF_KIND_R8), dimension(:,:), allocatable :: x_array
      real(kind=ESMF_KIND_R8), dimension(:,:), pointer :: x_ptr
      integer :: status, rc

      x = XR8
      call ESMF_FieldGet(x, farrayPtr = x_ptr, _RC)
      x_array = x_ptr
      call FieldSCAL(a, x, _RC)
      call ESMF_FieldGet(x, farrayPtr = x_ptr, _RC)
      @assertEqual(x_ptr, a*x_array)

   end subroutine test_FieldSCAL_R8

   @Test
   !
   subroutine test_FieldAXPY_R4()
      real(kind=ESMF_KIND_R4), parameter :: a = 2.0
      type(ESMF_Field) :: x
      type(ESMF_Field) :: y
      real(kind=ESMF_KIND_R4), dimension(:,:), allocatable :: x_array
      real(kind=ESMF_KIND_R4), dimension(:,:), pointer :: x_ptr
      real(kind=ESMF_KIND_R4), dimension(:,:), allocatable :: y_array
      real(kind=ESMF_KIND_R4), dimension(:,:), pointer :: y_ptr
      integer :: status, rc

      x = XR4
      y = YR4
      call ESMF_FieldGet(x, farrayPtr = x_ptr, _RC)
      x_array = x_ptr
      call ESMF_FieldGet(y, farrayPtr = y_ptr, _RC)
      y_array = y_ptr
      call FieldAXPY(a, x, y, _RC)
      call ESMF_FieldGet(x, farrayPtr = x_ptr, _RC)
      call ESMF_FieldGet(y, farrayPtr = y_ptr, _RC)
      @assertEqual(y_ptr, a*x_array+y_array)

   end subroutine test_FieldAXPY_R4

   @Test
   !
   subroutine test_FieldAXPY_R8()
      real(kind=ESMF_KIND_R8), parameter :: a = 2.0
      type(ESMF_Field) :: x
      type(ESMF_Field) :: y
      real(kind=ESMF_KIND_R8), dimension(:,:), allocatable :: x_array
      real(kind=ESMF_KIND_R8), dimension(:,:), pointer :: x_ptr
      real(kind=ESMF_KIND_R8), dimension(:,:), allocatable :: y_array
      real(kind=ESMF_KIND_R8), dimension(:,:), pointer :: y_ptr
      integer :: status, rc

      x = XR8
      y = YR8
      call ESMF_FieldGet(x, farrayPtr = x_ptr, _RC)
      x_array = x_ptr
      call ESMF_FieldGet(y, farrayPtr = y_ptr, _RC)
      y_array = y_ptr
      call FieldAXPY(a, x, y, _RC)
      call ESMF_FieldGet(x, farrayPtr = x_ptr, _RC)
      call ESMF_FieldGet(y, farrayPtr = y_ptr, _RC)
!      @assertEqual(y_ptr, a*x_array+y_array) !wdb fixme Temporarily disabled

   end subroutine test_FieldAXPY_R8

   @Test
   subroutine test_FieldGetLocalElementCount()
      type(ESMF_Field) :: x
      integer :: rank
      integer, allocatable :: expected_count(:)
      integer, allocatable :: actual_count(:)
      integer :: status, rc
      
      x = XR4
      call ESMF_FieldGet(x, rank=rank, _RC)
      allocate(expected_count(rank))
      call ESMF_FieldGet(x, localElementCount=expected_count, _RC)
      actual_count = FieldGetLocalElementCount(x, _RC)
      @assertEqual(actual_count, expected_count)
      if(allocated(expected_count)) deallocate(expected_count)
   
   end subroutine test_FieldGetLocalElementCount

   @Test
    !
   subroutine test_FieldGetLocalSize()
      type(ESMF_Field) :: x
      integer :: status, rc
      integer :: rank
      integer :: expected_size
      integer :: actual_size
      integer, allocatable :: element_count(:)

      x = XR4
      call ESMF_FieldGet(x, rank=rank, _RC)
      allocate(element_count(rank))
      call ESMF_FieldGet(x, localElementCount=element_count, _RC)
      expected_size = sum(element_count)
      actual_size=FieldGetLocalSize(x, _RC)
      @assertEqual(actual_size, expected_size)
      if(allocated(element_count)) deallocate(element_count)

   end subroutine test_FieldGetLocalSize

   @Test
   ! Test getting the c_ptr for a field
   !wdb fixme  Should test more extensively for different ranks
   !wdb fixme  Should test for ESMF_KIND_I4 and ESMF_KIND_I8
   !wdb fixme  Should check c_cptr from tested method against independent test

   subroutine test_FieldGetCptr()
      type(ESMF_Field) :: x
      type(c_ptr) :: cptr
      integer :: status, rc

      x = XR4
      call FieldGetCptr(x, cptr, _RC)
      x = XR8
      call FieldGetCptr(x, cptr, _RC)

   end subroutine test_FieldGetCptr

   @Test
   !wdb fixme  Probably should test for non-conformable fields
   subroutine test_FieldsAreConformableR4()
      type(ESMF_Field) :: x, y
      integer :: status, rc
      logical :: are_conformable

      x = XR4
      y = YR4
      are_conformable = .FALSE.
      are_conformable = FieldsAreConformable(x, y, _RC)
      @assertTrue(are_conformable)

   end subroutine test_FieldsAreConformableR4

   !wdb fixme  Probably should test for non-conformable fields
   @Test
   subroutine test_FieldsAreConformableR8()
      type(ESMF_Field) :: x, y
      integer :: status, rc
      logical :: are_conformable

      x = XR8
      y = YR8
      are_conformable = .FALSE.
      are_conformable = FieldsAreConformable(x, y, _RC)
      @assertTrue(are_conformable)

   end subroutine test_FieldsAreConformableR8

   @Test
   !
   subroutine test_FieldsAreSameTypeKind()
      type(ESMF_Field) :: x, y
      integer :: status, rc
      logical :: are_same_typekind

      x = XR4
      y = YR4
      are_same_typekind = .FALSE.
      are_same_typekind = FieldsAreSameTypeKind(x, y, _RC)
      @assertTrue(are_same_typekind) 
      x = XR8
      y = YR8
      are_same_typekind = .FALSE.
      are_same_typekind = FieldsAreSameTypeKind(x, y, _RC)
      @assertTrue(are_same_typekind)
      y = YR4
      are_same_typekind = .TRUE.
      are_same_typekind = FieldsAreSameTypeKind(x, y, _RC)
      @assertFalse(are_same_typekind)
      are_same_typekind = .TRUE.
      are_same_typekind = FieldsAreSameTypeKind(y, x, _RC)
      @assertFalse(are_same_typekind)

   end subroutine test_FieldsAreSameTypeKind

!wdb fixme Enable assertEqual
   @Test
   subroutine test_FieldConvertPrec_R4R8()
      integer, parameter :: NROWS = 4
      integer, parameter :: NCOLS = NROWS
      type(ESMF_Field) :: r4_field, r8_field
      real(kind=ESMF_KIND_R4) :: r4_data(NROWS,NCOLS)
      real(kind=ESMF_KIND_R8) :: r8_data(NROWS,NCOLS)
      real(kind=ESMF_KIND_R8) :: r8_converted(NROWS,NCOLS)
      real(kind=ESMF_KIND_R8), pointer :: r8_pointer(:,:)
      real(kind=ESMF_KIND_R4), allocatable :: r4_values(:,:)
      real(kind=ESMF_KIND_R8), allocatable :: r8_values(:,:)
      integer :: rc, status

      call initialize_array(r4_data, 0.0, 1.0)
      r8_data = 0.0
      r8_converted = r4_data
      r4_field = mk_field(r4_data, regDecomp = REG_DECOMP_DEFAULT, minIndex = [1, 1], &
         maxIndex = [NROWS, NCOLS], indexflag = INDEX_FLAG_DEFAULT, &
         name = 'XR4', _RC)
      r8_field = mk_field(r8_data, regDecomp = REG_DECOMP_DEFAULT, minIndex = [1, 1], &
         maxIndex = [NROWS, NCOLS], indexflag = INDEX_FLAG_DEFAULT, &
         name = 'YR8', _RC)
      call FieldConvertPrec(r4_field, r8_field, _RC)
      call ESMF_FieldGet(r8_field, farrayPtr = r8_pointer, _RC)
!      @assertEqual(r8_converted, r8_pointer) !wdb fixme temporarily disabled

   end subroutine test_FieldConvertPrec_R4R8

   !@Test
   !wdb fixme not done yet
   subroutine test_FieldClone()
      type(ESMF_Field) :: x, y
      integer :: status, rc

!      type(ESMF_ArraySpec) :: arrayspec
!      type(ESMF_Grid) :: grid
!      type(ESMF_StaggerLoc) :: staggerloc
!      integer, allocatable :: gridToFieldMap(:)
!      integer, allocatable :: ungriddedLBound(:)
!      integer, allocatable :: ungriddedUBound(:)
!      integer, allocatable :: totalLWidth(:,:)
!      integer, allocatable :: totalUWidth(:,:)

      x = XR4
      call FieldClone(x, y, _RC)

   end subroutine test_FieldClone

!wdb setup routines
   subroutine initialize_array_R4(x, xmin, xrange)
      real(ESMF_KIND_R4), intent(inout) :: x(:,:)
      real(ESMF_KIND_R4), intent(in) :: xmin
      real(ESMF_KIND_R4), intent(in) :: xrange
      integer :: rc, status

      _ASSERT(xrange > 0, 'Range for random numbers must be positive.')
      call random_number(x)
      x = xrange * x + xmin

   end subroutine initialize_array_R4

   subroutine initialize_array_R8(x, xmin, xrange)
      real(ESMF_KIND_R8), intent(inout) :: x(:,:)
      real(ESMF_KIND_R8), intent(in) :: xmin
      real(ESMF_KIND_R8), intent(in) :: xrange
      integer :: rc, status

      _ASSERT(xrange > 0, 'Range for random numbers must be positive.')
      call random_number(x)
      x = xrange * x + xmin

   end subroutine initialize_array_R8

   elemental function are_almost_equal(x, y) result(almost_equal)
      real(kind=ESMF_KIND_R4), parameter :: EPS = epsilon(real(1.0, kind=ESMF_KIND_R4))
      real(kind=ESMF_KIND_R8), intent(in) :: x
      real(kind=ESMF_KIND_R4), intent(in) :: y
      logical :: almost_equal

      if(y==0) then
         almost_equal = (x==0)
      else
         almost_equal = (abs(x-y)/abs(y) < EPS)
      end if

   end function are_almost_equal

   @Test
   subroutine test_almost_equal_scalar()
      real(kind=ESMF_KIND_R8), parameter :: X = 1.0 / 3.0
      real(kind=ESMF_KIND_R4) :: y

      y = X
      @assertTrue(are_almost_equal(X, y), trim(difference_string(X, y)))
      
   end subroutine test_almost_equal_scalar
      
   @Test
   subroutine test_almost_equal_array()
      integer, parameter :: N = 3
      real(kind=ESMF_KIND_R8), parameter :: DENOMS(N) = [3.0, 5.0, 7.0]
      real(kind=ESMF_KIND_R8), parameter :: X(N) = 1.0 / DENOMS
      real(kind=ESMF_KIND_R4) :: y(N)

      y = X

      @assertTrue(all(are_almost_equal(x, y)), trim(difference_string(x, y)))

   end subroutine test_almost_equal_array


   function difference_scalar(x, y) result(string)
      character(len=*), parameter :: fmt_ = '(A,1X,E)'
      character(len=*), parameter :: MSG = 'Difference is too large:'
      real(kind=ESMF_KIND_R8), intent(in) :: x
      real(kind=ESMF_KIND_R4), intent(in) :: y
      character(len=(len_trim(MSG)+32)) :: string
      write(string, fmt=fmt_) MSG, abs(x-y)
   end function difference_scalar

   function difference_array(x, y) result(string)
      character(len=*), parameter :: fmt_ = '(A,1X,E)'
      character(len=*), parameter :: MSG = 'Difference is too large:'
      real(kind=ESMF_KIND_R8), intent(in) :: x(:)
      real(kind=ESMF_KIND_R4), intent(in) :: y(:)
      character(len=(len_trim(MSG)+32)) :: string
      write(string, fmt=fmt_) MSG, maxval(abs(x-y))
   end function difference_array

end module Test_FieldBLAS
!   @Test
!   !
!   subroutine test_FieldGEMV_R4()
!      real(kind=ESMF_KIND_R4), parameter :: alpha = 3.0
!      real(kind=ESMF_KIND_R4), parameter :: A(*,*,*)
!      type(ESMF_Field) :: x
!      real(kind=ESMF_KIND_R4), parameter :: beta = 2.0
!      type(ESMF_Field) :: y
!      real(kind=ESMF_KIND_R8), dimension(:,:), allocatable :: x_array
!      real(kind=ESMF_KIND_R8), dimension(:,:), pointer :: x_ptr
!      real(kind=ESMF_KIND_R8), dimension(:,:), allocatable :: y_array
!      real(kind=ESMF_KIND_R8), dimension(:,:), pointer :: y_ptr
!      integer :: status, rc

!      allocate(x_array, source = R4_ARRAY_DEFAULT)
!      allocate(y_array, source = R4_ARRAY_DEFAULT)
!      y_array = y_array + 100

!      do while(.TRUE.)
!         x = mk_field(x_array, _RC)
!         if(status /= ESMF_SUCCESS) exit

!         y = mk_field(y_array, _RC)
!         if(status /= ESMF_SUCCESS) exit

!         call FieldAXPY(a, x, y, _RC)
!         if(status /= ESMF_SUCCESS) exit
!         
!         call ESMF_FieldGet(x, farrayPtr = x_ptr, _RC)
!         if(status /= ESMF_SUCCESS) exit

!         call ESMF_FieldGet(y, farrayPtr = y_ptr, _RC)
!         if(status /= ESMF_SUCCESS) exit

!         @assertEqual(y_ptr, a*x_array+y_array)
!         exit
!      end do
!
!   end subroutine test_FieldGEMV_R4

!   @Test
!   !
!   subroutine test_FieldSpread()
!   end subroutine test_FieldSpread
