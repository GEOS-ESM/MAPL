#include "MAPL_TestErr.h"
#include "unused_dummy.H"

module Test_StateDestroy
   use mapl3g_StateDestroy
   use pfunit
   use ESMF_TestMethod_mod
   use esmf

   implicit none(type, external)

   type(ESMF_Field) :: original

contains

   @Before
   subroutine setUp(this)
      class(ESMF_TestMethod), intent(inout) :: this
      type(ESMF_TypeKind_Flag), parameter :: TYPEKIND = ESMF_TYPEKIND_R4
      type(ESMF_Grid) :: grid
      integer :: status
      integer, parameter :: MAX_INDEX(2) = [4, 4]
      integer, parameter :: REG_DECOMP(2) = [1, 1]

      grid = ESMF_GridCreate(regDecomp=REG_DECOMP, maxIndex=MAX_INDEX, _RC)
      original = ESMF_FieldCreate(grid=grid, typekind=typekind, _RC)

      _UNUSED_DUMMY(this)

   end subroutine setUp
   
   @After
   subroutine shutDown(this)
      class(ESMF_TestMethod), intent(inout) :: this
      type(ESMF_Grid) :: grid
      integer :: status

      call ESMF_FieldGet(original, grid=grid, _RC)
      call ESMF_FieldDestroy(original, _RC)
      call ESMF_GridDestroy(grid, _RC)

      _UNUSED_DUMMY(this)

   end subroutine shutDown

   @Test(type=ESMF_TestMethod, npes=[1])
   subroutine test_MAPL_StateDestroy(this)
      class(ESMF_TestMethod), intent(inout) :: this
      type(ESMF_State) :: state
      integer :: status
      _UNUSED_DUMMY(this)

      state = ESMF_StateCreate(_RC)
      call MAPL_StateDestroy(state, destroy_contents=.FALSE., _RC)
      call ESMF_StateValidate(state, rc=status)
      @assertTrue(status /= ESMF_SUCCESS, 'state was not successfully destroyed.')

   end subroutine test_MAPL_StateDestroy

   @Test(type=ESMF_TestMethod, npes=[1])
   subroutine test_MAPL_StateDestroy_contents(this)
      class(ESMF_TestMethod), intent(inout) :: this
      integer, parameter :: NUM = 4
      integer  :: expected_item_count
      type(ESMF_State) :: state
      type(ESMF_Field) :: fields(NUM)
      type(ESMF_FieldBundle) :: bundles(NUM)
      type(ESMF_State) :: nestedStates(NUM)
      integer :: i, j, status, itemCount

      expected_item_count = 0
      do i=1, NUM
         do j=1, NUM
            call make_bundle(original, NUM, bundles(j), _RC)
            call ESMF_FieldBundleGet(bundles(j), fieldList=fields, _RC)
         end do
         call make_fields(original, fields, _RC)
         nestedStates(i) = ESMF_StateCreate(fieldbundleList=bundles, &
            & fieldList=fields, _RC)
         expected_item_count = expected_item_count + size(bundles) + size(fields)
      end do
      do i=1, NUM
         call make_bundle(original, NUM, bundles(i), _RC)
         call ESMF_FieldBundleGet(bundles(i), fieldList=fields, _RC)
      end do
      call make_fields(original, fields, _RC)
      
      state = ESMF_StateCreate(nestedStateList=nestedStates,&
         & fieldbundleList=bundles, fieldList=fields, _RC)
      expected_item_count = expected_item_count + size(nestedStates) + size(bundles) + size(fields)
      call ESMF_StateGet(state, nestedFlag=.TRUE., itemCount=itemCount, _RC)
      @assertEqual(expected_item_count, itemCount, 'The number of items was incorrect.') 
      call ESMF_StateValidate(state, nestedFlag=.TRUE., rc=status)
      @assertFalse(status /= ESMF_SUCCESS, 'The state is invalid.')
      call MAPL_StateDestroy(state, destroy_contents=.TRUE., _RC)
      call ESMF_StateValidate(state, nestedFlag=.TRUE., rc=status)
      @assertTrue(status /= ESMF_SUCCESS, 'The state was not successfully destroyed.')

      _UNUSED_DUMMY(this)
      
   end subroutine test_MAPL_StateDestroy_contents

   subroutine make_fields(field, fields, rc)
      type(ESMF_Field), intent(inout) :: field
      type(ESMF_Field), intent(inout) :: fields(:)
      integer, optional, intent(out) :: rc
      integer :: status
      integer :: i
      logical :: created

      do i=1, size(fields)
         fields(i) = ESMF_FieldCreate(field, _RC)
         created = ESMF_FieldIsCreated(fields(i), _RC)
         if(created) cycle
         _RETURN(_FAILURE)
      end do
      _RETURN(_SUCCESS)

   end subroutine make_fields

   subroutine make_bundle(field, n, bundle, rc)
      type(ESMF_Field), intent(inout) :: field
      integer, intent(in) :: n
      type(ESMF_FieldBundle), intent(inout) :: bundle
      integer, optional, intent(out) :: rc
      integer :: status
      integer :: fieldCount
      type(ESMF_Field), allocatable :: fields(:)
     
      allocate(fields(n))      
      call make_fields(field, fields, _RC)
      bundle = ESMF_FieldBundleCreate(fieldList=fields, _RC)
      call ESMF_FieldBundleGet(bundle, fieldCount=fieldCount, _RC)
      status = _SUCCESS
      if(fieldCount /= n) status = _FAILURE
      _RETURN(_SUCCESS)

   end subroutine make_bundle

end module Test_StateDestroy
