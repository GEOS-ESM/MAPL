#if defined(TRIMALL)
#  undef TRIMALL
#endif
#define TRIMALL(A) trim(adjustl(A))

module Test_FieldCondensedArray

    use pfunit
    use mapl3g_FieldCondensedArray_private
    implicit none

    character, parameter :: GENERIC_MESSAGE = 'actual does not match expected.'
    
contains

    @Test
    subroutine test_get_array_shape_3D()
       integer :: expected(3), actual(3)
       integer, allocatable :: gridToFieldMap(:)
       integer, allocatable :: localElementCount(:)
       integer, allocatable :: vertical_dims(:)

       gridToFieldMap = [1, 2]
       localElementCount = [3, 5, 7]
       vertical_dims = [3]
       expected = [product(localElementCount(1:2)), localElementCount(3), 1]
       actual = get_array_shape(gridToFieldMap, localElementCount, vertical_dims)
       @assertEqual(actual, expected, GENERIC_MESSAGE)

    end subroutine test_get_array_shape_3D

    @Test
    subroutine test_get_array_shape_2D()
       integer :: expected(3), actual(3)
       integer, allocatable :: gridToFieldMap(:)
       integer, allocatable :: localElementCount(:)

       gridToFieldMap = [1, 2]
       localElementCount = [3, 5]
       expected = [product(localElementCount), 1, 1]
       actual = get_array_shape(gridToFieldMap, localElementCount)
       @assertEqual(actual, expected, GENERIC_MESSAGE)

    end subroutine test_get_array_shape_2D

    @Test
    subroutine test_get_array_shape_general()
       integer :: expected(3), actual(3)
       integer, allocatable :: gridToFieldMap(:)
       integer, allocatable :: localElementCount(:)
       integer, allocatable :: vertical_dims(:)

       gridToFieldMap = [1, 2]
       vertical_dims = [3]
       localElementCount = [2, 3, 5, 7, 11]
       expected = [product(localElementCount(1:2)), localElementCount(3), product(localElementCount(4:))]
       actual = get_array_shape(gridToFieldMap, localElementCount, vertical_dims)
       @assertEqual(actual, expected, GENERIC_MESSAGE)

    end subroutine test_get_array_shape_general

    @Test
    subroutine test_get_array_shape_noz()
       integer :: expected(3), actual(3)
       integer, allocatable :: gridToFieldMap(:)
       integer, allocatable :: localElementCount(:)

       gridToFieldMap = [1, 2]
       localElementCount = [2, 3, 5, 7]
       expected = [product(localElementCount(1:2)), 1, product(localElementCount(3:))]
       actual = get_array_shape(gridToFieldMap, localElementCount)
       @assertEqual(actual, expected, GENERIC_MESSAGE)

    end subroutine test_get_array_shape_noz

    @Test
    subroutine test_get_array_shape_0D()
       integer :: expected(3), actual(3)
       integer, allocatable :: gridToFieldMap(:)
       integer, allocatable :: localElementCount(:)

       gridToFieldMap = [0, 0]
       localElementCount = [5, 7, 11]
       expected = [1, 1, product(localElementCount)]
       actual = get_array_shape(gridToFieldMap, localElementCount)
       @assertEqual(actual, expected, GENERIC_MESSAGE)

    end subroutine test_get_array_shape_0D

    subroutine test_get_array_shape_vert_only()
       integer :: expected(3), actual(3)
       integer, allocatable :: gridToFieldMap(:)
       integer, allocatable :: localElementCount(:)
       integer, allocatable :: vertical_dims(:)

       gridToFieldMap = [0, 0]
       vertical_dims = [3]
       localElementCount = vertical_dims
       expected = [1, localElementCount(1), 1]
       actual = get_array_shape(gridToFieldMap, localElementCount, vertical_dims)
       @assertEqual(actual, expected, GENERIC_MESSAGE)

    end subroutine test_get_array_shape_vert_only

    subroutine test_get_array_shape_vert_ungrid()
       integer :: expected(3), actual(3)
       integer, allocatable :: gridToFieldMap(:)
       integer, allocatable :: localElementCount(:)
       integer, allocatable :: vertical_dims(:)

       gridToFieldMap = [0, 0]
       vertical_dims = [3]
       localElementCount = [vertical_dims, 5, 7]
       expected = [1, localElementCount(1), product(localElementCount(2:))]
       actual = get_array_shape(gridToFieldMap, localElementCount, vertical_dims)
       @assertEqual(actual, expected, GENERIC_MESSAGE)

    end subroutine test_get_array_shape_vert_ungrid
    
    @Test
    subroutine test_get_array_shape_2D_ungrid()
       integer :: expected(3), actual(3)
       integer, allocatable :: gridToFieldMap(:)
       integer, allocatable :: localElementCount(:)

       gridToFieldMap = [1, 2]
       localElementCount = [3, 5, 7, 11]
       expected = [product(localElementCount(1:2)), 1, product(localElementCount(3:))]
       actual = get_array_shape(gridToFieldMap, localElementCount)
       @assertEqual(actual, expected, GENERIC_MESSAGE)

    end subroutine test_get_array_shape_2D_ungrid

    @Test
    subroutine test_get_array_shape_wrong_order()
       integer :: expected(3), actual(3)
       integer, allocatable :: gridToFieldMap(:)
       integer, allocatable :: localElementCount(:)
       integer, allocatable :: vertical_dims(:)
       integer :: status

       gridToFieldMap = [4, 5]
       vertical_dims = [3]
       localElementCount = [2, 3, 5, 7, 11]
       actual = get_array_shape(gridToFieldMap, localElementCount, vertical_dims, rc=status)
       @assertExceptionRaised()

    end subroutine test_get_array_shape_wrong_order
!    function make_error_message(prelude, actual, interlude,  expected, postlude) result(string)
!       character(len=:), allocatable :: string
!       character(len=*), intent(in) :: prelude, interlude, postlude
!       integer, intent(in) :: actual(:), expected(:)
!       character(len=:), allocatable :: raw
!
!       raw = make_array_string(actual)
!       if(size(raw) == 0) raw = 'NO ACTUAL'
!       string = trim(raw) // interlude
!       raw = make_array_string(expected)
!       if(size(raw) == 0) raw = 'NO EXPECTED'
!       string = trim(prelude) // string // trim(raw) // trim(postlude)
!
!    end function make_error_message
!
!    function make_array_string(arr) result(string)
!       character(len=:), allocatable :: string
!       integer, intent(in) :: arr(:)
!       character, parameter :: HFMT = '(I0)'
!       character, parameter :: TFMT = '(1X, I0)'
!       character(len=:), allocatable :: raw
!       integer :: i, iostat
!
!       if(size(arr) == 0) then
!          string = '[]'
!          return
!       end if
!       string = ''
!       write(raw, fmt=HFMT, iostat=iostat, advance = 'NO') arr(1)
!       if(iostat /= 0) return
!       string = '[ ' // TRIMALL(raw)
!       do i=2, size(arr)
!         write(raw, fmt=TFMT, iostat=iostat, advance='NO') arr(i)
!         if(iostat /= 0) then
!            string = ''
!         end if
!         string = string // TRIMALL(raw)
!      end do
!      string = string // ']'
!
!   end function make_array_string

end module Test_FieldCondensedArray

