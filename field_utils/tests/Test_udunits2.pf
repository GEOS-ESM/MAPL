#ifdef FULLTEST
#undef FULLTEST
#endif

! Normally, udunits2mod private procedures are not tested.
! To test private procedures, uncomment the #define FULLTEST line,
! which is the last line of this comment block, and comment out the global 
! private attribute in udunits2mod.
!#define FULLTEST

module Test_udunits2

   use funit
   use udunits2mod, finalize_udunits_system => finalize, initialize_udunits_system => initialize
   use iso_c_binding, only: c_ptr, c_null_ptr, c_double, c_float, c_associated

   implicit none

   integer(ut_encoding), parameter :: ENCODING = UT_ASCII
   character(len=*), parameter :: KM = 'km'
   character(len=*), parameter :: M = 'm'
   character(len=*), parameter :: S = 's'

contains

   @Test
   subroutine test_get_converter()
      type(Converter) :: conv
      type(c_ptr) :: cptr
      integer(ut_status) :: status

      call initialize_udunits_system(rc=status)
      @assertEqual(UT_SUCCESS, status, 'Failed to initialize')
      call get_converter(conv, KM, M, rc=status)
      @assertEqual(UT_SUCCESS, status, 'Failed to get converter')
      @assertFalse(conv % is_free(), 'cv_converter is not set')
      cptr = conv % cptr()
      @assertTrue(c_associated(cptr), 'c_ptr is not associated')
      
      call conv % free()
      call finalize_udunits_system()
      
  end subroutine test_get_converter

   @Test
   subroutine test_convert_double()
      real(c_double), parameter :: FROM = 1.0
      real(c_double), parameter :: EXPECTED = 1000.0
      real(c_double) :: actual
      type(Converter) :: conv
      integer(ut_status) :: status
      character(len=*), parameter :: FROM_STRING = KM
      character(len=*), parameter :: TO_STRING = M

      call initialize_udunits_system(rc=status)
      @assertEqual(UT_SUCCESS, status, 'Failed to initialize')
      call get_converter(conv, FROM_STRING, TO_STRING, rc=status)
      @assertEqual(UT_SUCCESS, status, 'Failed to get converter')
      call conv % convert(FROM, actual, rc=status)
      @assertEqual(UT_SUCCESS, status, 'Converter failed')
      @assertEqual(actual, EXPECTED, 'Actual does not equal expected.')
      call conv % free()
      call finalize_udunits_system()

   end subroutine test_convert_double

   @Test
   subroutine test_convert_float()
      real(c_float), parameter :: FROM = 1.0
      real(c_float), parameter :: EXPECTED = 1000.0
      real(c_float) :: actual
      type(Converter) :: conv
      integer(ut_status) :: status
      character(len=*), parameter :: FROM_STRING = KM
      character(len=*), parameter :: TO_STRING = M

      call initialize_udunits_system(rc=status)
      @assertEqual(UT_SUCCESS, status, 'Failed to initialize')
      call get_converter(conv, FROM_STRING, TO_STRING, rc=status)
      @assertEqual(UT_SUCCESS, status, 'Failed to get converter')
      call conv % convert(FROM, actual, rc=status)
      @assertEqual(UT_SUCCESS, status, 'Converter failed')
      @assertEqual(actual, EXPECTED, 'Actual does not equal expected.')
      call conv % free()
      call finalize_udunits_system()

   end subroutine test_convert_float

   @Test
   subroutine test_convert_doubles()
      real(c_double), parameter :: FROM(3) = [1.0, 2.0, 3.0]
      real(c_double), parameter :: EXPECTED(3) = 1000.0 * FROM
      real(c_double) :: actual(size(EXPECTED))
      type(Converter) :: conv
      integer(ut_status) :: status
      character(len=*), parameter :: FROM_STRING = KM
      character(len=*), parameter :: TO_STRING = M

      call initialize_udunits_system(rc=status)
      @assertEqual(UT_SUCCESS, status, 'Failed to initialize')
      call get_converter(conv, FROM_STRING, TO_STRING, rc=status)
      @assertEqual(UT_SUCCESS, status, 'Failed to get converter')
      call conv % convert(FROM, actual, status)
      @assertEqual(UT_SUCCESS, status, 'Converter failed')
      @assertEqual(actual, EXPECTED, 'Actual does not equal expected.')
      call conv % free()
      call finalize_udunits_system()

   end subroutine test_convert_doubles

   @Test
   subroutine test_convert_floats()
      real(c_float), parameter :: FROM(3) = [1.0, 2.0, 3.0]
      real(c_float), parameter :: EXPECTED(3) = 1000.0 * FROM
      real(c_float) :: actual(size(EXPECTED))
      type(Converter) :: conv
      integer(ut_status) :: status
      character(len=*), parameter :: FROM_STRING = KM
      character(len=*), parameter :: TO_STRING = M

      call initialize_udunits_system(rc=status)
      @assertEqual(UT_SUCCESS, status, 'Failed to initialize')
      call get_converter(conv, FROM_STRING, TO_STRING, rc=status)
      @assertEqual(UT_SUCCESS, status, 'Failed to get converter')
      call conv % convert(FROM, actual, rc=status)
      @assertEqual(UT_SUCCESS, status, 'Converter failed')
      @assertEqual(actual, EXPECTED, 'Actual does not equal expected.')
      call conv % free()
      call finalize_udunits_system()

   end subroutine test_convert_floats

#if defined(FULLTEST)

   @Test
   subroutine test_construct_system_no_path()
      type(UDSystem) :: wrapper
      
      wrapper = UDSystem()
      @assertFalse(wrapper % is_free(), 'ut_system is not set')
      call ut_free_system(wrapper % cptr())

   end subroutine test_construct_system_no_path

   @Test
   subroutine test_cptr_wrapper()
      type(UDSystem) :: wrapper
      type(c_ptr) :: cptr
      logical :: cassoc

      wrapper = UDSystem()
      cptr = wrapper % cptr()
      cassoc = c_associated(cptr)
      @assertTrue(cassoc, 'Did not get c_ptr')
      if(cassoc) then
         @assertFalse(wrapper % is_free(), 'c_ptr should be set.')
         call wrapper % free()
         cptr = wrapper % cptr()
         @assertFalse(c_associated(cptr), 'c_ptr should not be associated')
         @assertTrue(wrapper % is_free(), 'c_ptr should not be set')
      end if
      if(c_associated(cptr)) call ut_free_system(cptr)

   end subroutine test_cptr_wrapper

   @Test
   subroutine test_construct_unit()
      type(UDUnit) :: unit1
      integer(ut_status) :: status
         
      call initialize_udunits_system(rc=status)
      @assertEqual(UT_SUCCESS, status, 'Failed to initialize')
      unit1 = UDUnit(KM)
      @assertFalse(unit1 % is_free(), 'ut_unit is not set (default encoding)')

      call unit1 % free()
      call finalize_udunits_system()
      
   end subroutine test_construct_unit

   @Test
   subroutine test_construct_converter()
      type(UDUnit) :: unit1
      type(UDUnit) :: unit2
      type(Converter) :: conv
      integer(ut_status) :: status
      
      call initialize_udunits_system(rc=status)
      @assertEqual(UT_SUCCESS, status, 'Failed to initialize')
      unit1 = UDUnit(KM)
      unit2 = UDUnit(M)
      conv = Converter(unit1, unit2) 
      @assertFalse(conv % is_free(), 'cv_converter is not set')
      
      call unit1 % free()
      call unit2 % free()
      call conv % free()
      call finalize_udunits_system()

   end subroutine test_construct_converter

   @Test
   subroutine test_read_xml_nopath()
      integer :: status
      type(c_ptr) :: utsystem

      call read_xml(utsystem=utsystem, rc=status)
      if(.not. c_associated(utsystem)) then
         @assertFalse(status == UT_OS, 'Operating system error')
         @assertFalse(status == UT_PARSE_ERROR, 'Database file could not be parsed.')
         @assertFalse(status == UT_OPEN_ARG, 'Non-null path could not be opened.')
         @assertFalse(status == UT_OPEN_ENV, 'Environment variable is set but could not open.')
         @assertFalse(status == UT_OPEN_DEFAULT, 'Default database could not be opened.')
      end if

      call ut_free_system(utsystem)

   end subroutine test_read_xml_nopath

   @Test
   subroutine test_cstring()
      character(len=*), parameter :: s = 'FOO_BAR'
      character(kind=c_char, len=80) :: cchs
      character(kind=kind(cchs)) :: cc
      integer :: n

      cchs = cstring(s)
      @assertEqual(kind((cchs)), c_char, 'Wrong kind')
      n = len_trim(cchs)
      @assertEqual(n, len(s)+1, 'cstring is incorrect length.')
      cc = cchs(n:n)
      @assertEqual(cc, c_null_char, 'Final character is not null.')
      @assertEqual(cchs(1:(n-1)), s, 'Initial characters do not match.')

   end subroutine test_cstring

   @Test
   subroutine test_are_convertible()
      type(UDUnit) :: unit1
      type(UDUnit) :: unit2
      integer(ut_status) :: status
      logical :: convertible

      call initialize_udunits_system(rc=status)
      @assertEqual(UT_SUCCESS, status, 'Failed to initialize')
      unit1 = UDUnit(KM)
      unit2 = UDUnit(M)
      convertible = are_convertible(unit1, unit2, rc=status)
      if(.not. convertible) then
         @assertFalse(status == UT_BAD_ARG, 'One of the units is null.')
         @assertFalse(status == UT_NOT_SAME_SYSTEM, 'Units belong to different systems.')
      end if

      call unit1 % free()
      call unit2 % free()
      call finalize_udunits_system()

   end subroutine test_are_convertible

   @Test
   subroutine test_are_not_convertible()
      type(UDUnit) :: unit1
      type(UDUnit) :: unit2
      integer(ut_status) :: status
      logical :: convertible

      call initialize_udunits_system(rc=status)
      @assertEqual(UT_SUCCESS, status, 'Failed to initialize')
      unit1 = UDUnit(KM)
      unit2 = UDUnit(S)
      convertible = are_convertible(unit1, unit2, rc=status)
      @assertFalse(convertible, 'Units are not convertible.')
      if(.not. convertible) then
         @assertFalse(status == UT_BAD_ARG, 'One of the units is null.')
         @assertFalse(status == UT_NOT_SAME_SYSTEM, 'Units belong to different systems.')
         @assertTrue(status == UT_SUCCESS, 'Units are not convertible.')
      end if

      call unit1 % free()
      call unit2 % free()
      call finalize_udunits_system()

   end subroutine test_are_not_convertible

#endif

end module Test_udunits2
