#if defined XML_PATH
#undef XML_PATH
#endif

! This needs to be set to a path to the xml unit database for testing.
!#define XML_PATH 

module Test_udunits2

   use funit
   use udunits2mod
   ! The instances from iso_c_binding are not explicitly included in an include
   ! statement, to verify that the use statement for the module being tested
   ! is correct.
   use iso_c_binding, only: c_ptr, c_null_ptr, c_double, c_float, c_associated

   implicit none

!   include 'udunits2enumerators.h'
!   include "udunits2interfaces.h"

   integer(ut_encoding) :: encoding = UT_ASCII
   type(c_ptr) :: ut_system_ptr, unit1, unit2
   character(len=*), parameter :: KM = 'km'
   character(len=*), parameter :: M = 'm'
   character(len=*), parameter :: S = 's'

contains

   @Before
   subroutine set_up()

      encoding = UT_ASCII
      call SYSTEM_INSTANCE % set()
      ut_system_ptr = c_null_ptr
      unit1 = c_null_ptr
      unit2 = c_null_ptr

   end subroutine set_up

   @After
   subroutine tear_down()

      encoding = UT_ASCII
      !call destroy_all()

      if(c_associated(unit1)) call ut_free(unit1)
      if(c_associated(unit2)) call ut_free(unit2)
      if(c_associated(ut_system_ptr)) call ut_free_system(ut_system_ptr)
!      if(.not. is_null(ut_system_ptr)) call ut_free_system(ut_system_ptr)
!      if(.not. is_null(unit1)) call ut_free(unit1)
!      if(.not. is_null(unit2)) call ut_free(unit2)

   end subroutine tear_down

   @Test
   subroutine test_get_unit_database_path()
      character(len=1024) :: path
      type(c_ptr) :: path_ptr
      integer(c_int) :: status

      path_ptr = get_unit_database_path(status)
      @assertEqual(status, UT_SUCCESS, 'Unsuccessful: ' // trim(path))
      @assertFalse(len_trim(path) == 0, 'Nonzero path: ' // trim(path))

   end subroutine test_get_unit_database_path

!   @Test
!   subroutine test_initialize()
!      type(c_ptr) :: ptr

!      ptr = initialize()
!      @assertEqual(ptr, c_null_ptr, 'initialize returned the C null pointer (no path).')

!#if defined XML_PATH
!      ptr = initialize(XML_PATH)
!      @assertTrue(c_associated(ptr), 'initialize returned the C null pointer (path).')
!#endif

!   end subroutine test_initialize
   
   !@Test
   subroutine test_get_converter()
      type(MAPL_Udunits_Converter) :: conv

      conv = get_converter(KM, M, encoding=encoding)
      @assertTrue(c_associated(conv % ptr), 'get_converter returned the C null pointer.')

   end subroutine test_get_converter

   !@Test
   subroutine test_get_converter_noencoding()
      type(MAPL_Udunits_Converter) :: conv

      conv = get_converter(KM, M)
      @assertTrue(c_associated(conv % ptr), 'get_converter returned the C null pointer.')

   end subroutine test_get_converter_noencoding

   !@Test
   subroutine test_get_ut_system()
      type(c_ptr) :: ptr
      logical :: destroyed

      ptr = get_ut_system()
      @assertTrue(c_associated(ptr), 'get_ut_system returned the C null pointer (no path).')
      call ut_free_system(ptr)

#if defined XML_PATH
      ptr = get_ut_system(XML_PATH)
      @assertTrue(c_associated(ptr), 'get_ut_system returned the C null pointer (path).')
      call ut_free_system(ptr)
#endif

   end subroutine test_get_ut_system

   !@Test
   subroutine test_are_convertible()
      type(c_ptr) :: unit1, unit2, ut_system_ptr
      
      ut_system_ptr = ut_read_xml(c_null_ptr)
      unit1 = ut_parse(ut_system_ptr, 'km', encoding)
      unit2 = ut_parse(ut_system_ptr, 'm', encoding)
      @assertTrue(are_convertible(unit1, unit2), 'Units are convertible.')

   end subroutine test_are_convertible

   !@Test
   subroutine test_are_not_convertible()
      type(c_ptr) :: unit1, unit2, ut_system_ptr

      ut_system_ptr = ut_read_xml(c_null_ptr)
      unit1 = ut_parse(ut_system_ptr, 'km', encoding)
      unit2 = ut_parse(ut_system_ptr, 's', encoding)
      @assertFalse(are_convertible(unit1, unit2), 'Units are not convertible.')

   end subroutine test_are_not_convertible

   !@Test
   subroutine test_ut_read_xml()
      type(c_ptr) :: path = c_null_ptr
      integer(ut_status) :: ustat
      type(c_ptr) :: utsys
      
      utsys = ut_read_xml(path)
      ustat = ut_get_status()
      @assertEqual(ustat, UT_SUCCESS, 'Failed to get ut_system')
      @assertTrue(c_associated(utsys), 'Unsuccessful ut_read_xml')
      call ut_free_system(utsys)

   end subroutine test_ut_read_xml

   !@Test
   subroutine test_ut_parse()
      type(c_ptr) :: utsys
      character(c_char), parameter :: string = 'kilogram'
      integer(ut_encoding) :: encoding
      type(c_ptr) :: path = c_null_ptr
      type(c_ptr) :: unit0
      integer(ut_status) :: ustat

      utsys = ut_read_xml(path)
      unit0 = ut_parse(utsys, string, encoding)
      ustat = ut_get_status()
      @assertEqual(ustat, UT_SUCCESS, 'Unsuccessful')
      
   end subroutine test_ut_parse

   !@Test
   subroutine test_convert_double()
      real(c_double), parameter :: FROM = 1.0
      real(c_double), parameter :: EXPECTED = 1000.0
      real(c_double) :: ACTUAL
      type(MAPL_Udunits_Converter) :: conv
      character(len=*), parameter :: FROM_STRING = KM
      character(len=*), parameter :: TO_STRING = M

      conv = get_converter(FROM_STRING, TO_STRING)
      ACTUAL = conv % convert_double(FROM)
      @assertEqual(ACTUAL, EXPECTED, 'Actual does not equal expected.')

   end subroutine test_convert_double

   !@Test
   subroutine test_convert_float()
      real(c_float), parameter :: FROM = 1.0
      real(c_float), parameter :: EXPECTED = 1000.0
      real(c_float) :: ACTUAL
      type(MAPL_Udunits_Converter) :: conv
      character(len=*), parameter :: FROM_STRING = KM
      character(len=*), parameter :: TO_STRING = M

      conv = get_converter(FROM_STRING, TO_STRING)
      ACTUAL = conv % convert_float(FROM)
      @assertEqual(ACTUAL, EXPECTED, 'Actual does not equal expected.')

   end subroutine test_convert_float

   !@Test
   subroutine test_convert_doubles()
      real(c_double), parameter :: FROM(3) = [1.0, 2.0, 3.0]
      real(c_double), parameter :: EXPECTED(3) = 1000.0 * FROM
      real(c_double) :: ACTUAL(size(EXPECTED))
      type(MAPL_Udunits_Converter) :: conv
      character(len=*), parameter :: FROM_STRING = KM
      character(len=*), parameter :: TO_STRING = M

      conv = get_converter(FROM_STRING, TO_STRING)
      call conv % convert_doubles(FROM, ACTUAL)
      @assertEqual(ACTUAL, EXPECTED, 'Actual does not equal expected.')

   end subroutine test_convert_doubles

   !@Test
   subroutine test_convert_floats()
      real(c_float), parameter :: FROM(3) = [1.0, 2.0, 3.0]
      real(c_float), parameter :: EXPECTED(3) = 1000.0 * FROM
      real(c_float) :: ACTUAL(size(EXPECTED))
      type(MAPL_Udunits_Converter) :: conv
      character(len=*), parameter :: FROM_STRING = KM
      character(len=*), parameter :: TO_STRING = M

      conv = get_converter(FROM_STRING, TO_STRING)
      call conv % convert_floats(FROM, ACTUAL)
      @assertEqual(ACTUAL, EXPECTED, 'Actual does not equal expected.')

   end subroutine test_convert_floats

   !@Test
   subroutine test_destroy_all()
      @assertTrue(.FALSE., 'Test not implemented')
   end subroutine test_destroy_all

   !@Test
   subroutine test_destroy_system()
      @assertTrue(.FALSE., 'Test not implemented')
   end subroutine test_destroy_system

   !@Test
   subroutine test_destroy_converter()
      @assertTrue(.FALSE., 'Test not implemented')
   end subroutine test_destroy_converter

   !@Test
   subroutine test_destroy_ut_unit()
      @assertTrue(.FALSE., 'Test not implemented')
   end subroutine test_destroy_ut_unit

end module Test_udunits2
