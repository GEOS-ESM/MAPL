#if defined XML_PATH
#undef XML_PATH
#endif

#if defined(MAXPATHLEN)
#undef MAXPATHLEN
#endif
#define MAXPATHLEN 1024

! This needs to be set to a path to the xml unit database for testing.
!#define XML_PATH 

module Test_udunits2

   use funit
   use udunits2mod
   ! The instances from iso_c_binding are not explicitly included in an include
   ! statement, to verify that the use statement for the module being tested
   ! is correct.
   use iso_c_binding, only: c_ptr, c_null_ptr, c_double, c_float, c_associated

   implicit none

!   include 'udunits2enumerators.h'
!   include "udunits2interfaces.h"

   integer(ut_encoding) :: encoding = UT_ASCII
   type(c_ptr) :: ut_system_ptr, unit1, unit2
!   integer, parameter :: MAXPATHLEN = 1024
   character(len=*), parameter :: KM = 'km'
   character(len=*), parameter :: M = 'm'
   character(len=*), parameter :: S = 's'

   character(kind=c_char, len=:), allocatable :: path_environment

contains

!   @Test
!   subroutine test_get_unit_database_path()
!      character(len=MAXPATHLEN) :: path
!      character(len=MAXPATHLEN) :: actual_path
!      integer(ut_status) :: status, expected_status
!      integer :: expected, actual
!      character(len=:), allocatable :: message
!
!      expected_status = UT_OPEN_ENV
!      expected = expected_status
!      call get_unit_database_path(actual_path, status=status)
!      actual = status
!   !   if(actual /= expected) message = get_ut_status_message(status) // ' /= ' // get_ut_status_message(expected_status)
!      @assertEqual(actual, expected, 'status codes do not match')
!      @assertTrue(len_trim(actual_path) > 0, 'zero length path: ' // trim(path))
!
!   end subroutine test_get_unit_database_path

!   @Test
!   subroutine test_initialize()
!      type(c_ptr) :: ptr

!      ptr = initialize()
!      @assertEqual(ptr, c_null_ptr, 'initialize returned the C null pointer (no path).')

!#if defined XML_PATH
!      ptr = initialize(XML_PATH)
!      @assertTrue(c_associated(ptr), 'initialize returned the C null pointer (path).')
!#endif

!   end subroutine test_initialize
   
   !@Test
   subroutine test_get_converter()
      type(MAPL_Udunits_Converter) :: conv

      conv = get_converter(KM, M, encoding=encoding)
      @assertTrue(c_associated(conv % ptr), 'get_converter returned the C null pointer.')

   end subroutine test_get_converter

   !@Test
   subroutine test_get_converter_noencoding()
      type(MAPL_Udunits_Converter) :: conv

      conv = get_converter(KM, M)
      @assertTrue(c_associated(conv % ptr), 'get_converter returned the C null pointer.')

   end subroutine test_get_converter_noencoding

!   @Test
   subroutine test_get_path_environment_variable()
      integer :: status
      character(len=MAXPATHLEN) :: xmlpath

      xmlpath = get_path_environment_variable(status)
      @assertTrue(status == 0, 'Non-zero status for get_environment variable')
      if(status /= 0) then
         @assertFalse(status == -1, 'local "value" variable is too short.')
         @assertFalse(status == 1, 'environment variable does not exist')
         @assertFalse(status == -2, 'zero length value')
         @assertFalse(status > 2, 'processor-dependent status')
         @assertFalse(status == 2, 'unrecognized status')
         @assertFalse(status < -2, 'invalid status')
      end if
      
      @assertTrue(len(trim(xmlpath)) < MAXPATHLEN, 'Trimmed path length too long')
   end subroutine test_get_path_environment_variable

   !@Test
!   subroutine test_get_ut_system()
!      type(c_ptr) :: ptr
!      logical :: destroyed
!
!      ptr = get_ut_system(trim(path_environment))
!      ptr = get_ut_system()
!      @assertTrue(c_associated(ptr), 'get_ut_system returned the C null pointer (no path).')
!      call ut_free_system(ptr)
!
!#if defined XML_PATH
!      ptr = get_ut_system(XML_PATH)
!      @assertTrue(c_associated(ptr), 'get_ut_system returned the C null pointer (path).')
!      call ut_free_system(ptr)
!#endif

!   end subroutine test_get_ut_system

   !@Test
   subroutine test_are_convertible()
!      type(c_ptr) :: unit1, unit2, ut_system_ptr
!      
!      ut_system_ptr = ut_read_xml(trim(path_environment))
!      unit1 = ut_parse(ut_system_ptr, 'km', encoding)
!      unit2 = ut_parse(ut_system_ptr, 'm', encoding)
!      @assertTrue(are_convertible(unit1, unit2), 'Units are convertible.')
!
   end subroutine test_are_convertible

   !@Test
   subroutine test_are_not_convertible()
!      type(c_ptr) :: unit1, unit2, ut_system_ptr
!
!      ut_system_ptr = ut_read_xml(trim(path_environment))
!      unit1 = ut_parse(ut_system_ptr, 'km', encoding)
!      unit2 = ut_parse(ut_system_ptr, 's', encoding)
!      @assertFalse(are_convertible(unit1, unit2), 'Units are not convertible.')
!
   end subroutine test_are_not_convertible

   @Test
   subroutine test_ut_read_xml()
      integer(ut_status) :: ustat
      type(c_ptr) :: utsys
      integer :: status
      character(len=1), target :: c
      c = c_null_char
      
      utsys = ut_read_xml(c_loc(c))
!      ustat = ut_get_status()
!      @assertEqual(ustat, UT_SUCCESS, 'Failed to get ut_system')
!      @assertTrue(c_associated(utsys), 'Unsuccessful ut_read_xml')
!      call ut_free_system(utsys)
      @assertTrue(.TRUE.)

   end subroutine test_ut_read_xml

   !@Test
!   subroutine test_ut_parse()
!      type(c_ptr) :: utsys
!      character(c_char), parameter :: string = 'kilogram'
!      integer(ut_encoding) :: encoding
!      type(c_ptr) :: path = c_null_ptr
!      type(c_ptr) :: unit0
!      integer(ut_status) :: ustat
!
!      utsys = ut_read_xml(trim(path_environment))
!      unit0 = ut_parse(utsys, string, encoding)
!      ustat = ut_get_status()
!      @assertEqual(ustat, UT_SUCCESS, 'Unsuccessful')
!      
!   end subroutine test_ut_parse

   !@Test
   subroutine test_convert_double()
      real(c_double), parameter :: FROM = 1.0
      real(c_double), parameter :: EXPECTED = 1000.0
      real(c_double) :: ACTUAL
      type(MAPL_Udunits_Converter) :: conv
      character(len=*), parameter :: FROM_STRING = KM
      character(len=*), parameter :: TO_STRING = M

      conv = get_converter(FROM_STRING, TO_STRING)
      ACTUAL = conv % convert_double(FROM)
      @assertEqual(ACTUAL, EXPECTED, 'Actual does not equal expected.')

   end subroutine test_convert_double

   !@Test
   subroutine test_convert_float()
      real(c_float), parameter :: FROM = 1.0
      real(c_float), parameter :: EXPECTED = 1000.0
      real(c_float) :: ACTUAL
      type(MAPL_Udunits_Converter) :: conv
      character(len=*), parameter :: FROM_STRING = KM
      character(len=*), parameter :: TO_STRING = M

      conv = get_converter(FROM_STRING, TO_STRING)
      ACTUAL = conv % convert_float(FROM)
      @assertEqual(ACTUAL, EXPECTED, 'Actual does not equal expected.')

   end subroutine test_convert_float

   !@Test
   subroutine test_convert_doubles()
      real(c_double), parameter :: FROM(3) = [1.0, 2.0, 3.0]
      real(c_double), parameter :: EXPECTED(3) = 1000.0 * FROM
      real(c_double) :: ACTUAL(size(EXPECTED))
      type(MAPL_Udunits_Converter) :: conv
      character(len=*), parameter :: FROM_STRING = KM
      character(len=*), parameter :: TO_STRING = M

      conv = get_converter(FROM_STRING, TO_STRING)
      call conv % convert_doubles(FROM, ACTUAL)
      @assertEqual(ACTUAL, EXPECTED, 'Actual does not equal expected.')

   end subroutine test_convert_doubles

   !@Test
   subroutine test_convert_floats()
      real(c_float), parameter :: FROM(3) = [1.0, 2.0, 3.0]
      real(c_float), parameter :: EXPECTED(3) = 1000.0 * FROM
      real(c_float) :: ACTUAL(size(EXPECTED))
      type(MAPL_Udunits_Converter) :: conv
      character(len=*), parameter :: FROM_STRING = KM
      character(len=*), parameter :: TO_STRING = M

      conv = get_converter(FROM_STRING, TO_STRING)
      call conv % convert_floats(FROM, ACTUAL)
      @assertEqual(ACTUAL, EXPECTED, 'Actual does not equal expected.')

   end subroutine test_convert_floats

   !@Test
   subroutine test_destroy_all()
      @assertTrue(.FALSE., 'Test not implemented')
   end subroutine test_destroy_all

   !@Test
   subroutine test_destroy_system()
      @assertTrue(.FALSE., 'Test not implemented')
   end subroutine test_destroy_system

   !@Test
   subroutine test_destroy_converter()
      @assertTrue(.FALSE., 'Test not implemented')
   end subroutine test_destroy_converter

   !@Test
   subroutine test_destroy_ut_unit()
      @assertTrue(.FALSE., 'Test not implemented')
   end subroutine test_destroy_ut_unit

   @Test
   subroutine test_get_ut_status_message()
      integer(ut_status) :: status_code
      character(len=80) :: message
      character(len=len(message)) :: expected
      
      status_code = -1
      expected = 'NOT FOUND'
      message = get_ut_status_message(status_code)
      @assertEqual(trim(expected), trim(message), '"' // trim(expected) // '" /= "' // trim(message) // '"')

      status_code = UT_PARSE_ERROR + 1
      message = get_ut_status_message(status_code)
      @assertTrue(trim(expected) == trim(message), '"' // trim(expected) // '" /= "' // trim(message) // '"')

      status_code = UT_SUCCESS
      expected = 'UT_SUCCESS'
      message = get_ut_status_message(status_code)
      @assertTrue(trim(expected) == trim(message), '"' // trim(expected) // '" /= "' // trim(message) // '"')

      status_code = UT_BAD_ARG
      expected = 'UT_BAD_ARG'
      message = get_ut_status_message(status_code)
      @assertEqual(trim(expected), trim(message), '"' // trim(expected) // '" /= "' // trim(message) // '"')

      status_code = UT_PARSE_ERROR
      expected = 'UT_PARSE_ERROR'
      message = get_ut_status_message(status_code)
      @assertEqual(trim(expected), trim(message), '"' // trim(expected) // '" /= "' // trim(message) // '"')

   end subroutine test_get_ut_status_message

!   @Test
   subroutine test_get_c_char_ptr()
      character(len=*), parameter :: S = '/dev/null'
      type(c_ptr) :: cptr

      cptr = get_c_char_ptr(S)
      @assertFalse(is_null(cptr), 'pointer should not be null')

   end subroutine test_get_c_char_ptr

   subroutine make_integer_string(n, s)
      integer, intent(in) :: n
      character(len=*), intent(inout) :: s
      character(len=*), parameter :: FMT_ = '(I32)'
      integer :: ios

      if(len(s) >= 32) then
         write(s, fmt=FMT_, iostat=ios) n
         if(ios == 0) then
            s = adjustl(s)
         else
            s = EMPTY_STRING
         end if
         return
      end if

      s = EMPTY_STRING
      
   end subroutine make_integer_string

   @Before
   subroutine set_up()
      integer(ut_status) :: status

      if(.not. allocated(path_environment)) &
         path_environment = get_path_environment_variable(status)

      encoding = UT_ASCII
      call SYSTEM_INSTANCE % set()
      ut_system_ptr = c_null_ptr
      unit1 = c_null_ptr
      unit2 = c_null_ptr

   end subroutine set_up

   @After
   subroutine tear_down()

      encoding = UT_ASCII
      !call destroy_all()

      if(allocated(path_environment)) deallocate(path_environment)
      if(c_associated(unit1)) call ut_free(unit1)
      if(c_associated(unit2)) call ut_free(unit2)
      if(c_associated(ut_system_ptr)) call ut_free_system(ut_system_ptr)
!      if(.not. is_null(ut_system_ptr)) call ut_free_system(ut_system_ptr)
!      if(.not. is_null(unit1)) call ut_free(unit1)
!      if(.not. is_null(unit2)) call ut_free(unit2)

   end subroutine tear_down

end module Test_udunits2
